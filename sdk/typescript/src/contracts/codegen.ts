/**
 * TypeScript code generator: ABI → strongly-typed contract client stubs.
 *
 * The generator returns a single .ts source string that:
 *   • Embeds the ABI as a `const ABI_JSON`
 *   • Exports a `class <ClassName> extends Contract` with:
 *       - constructor(address: string)
 *       - build<Method>Tx(args, p)
 *       - <method>(client, signer, args, p, wait?)
 *   • Exports typed arg tuples & named-arg interfaces per function
 *   • Exports `EventTopics` and `decodeEvents()` helpers
 *
 * The generated class depends only on public SDK entry-points:
 *   - contracts/client (Contract, CallTxParams)
 *   - tx/send (RpcClient, WaitOpts)
 *   - tx/build (UnsignedTx)
 *   - contracts/events (matchAndDecodeLogs)
 *   - types/abi (ABI)
 *
 * Usage:
 *   import { generateContractClientTS } from '@animica/sdk/contracts/codegen'
 *   const src = generateContractClientTS(myAbi, { className: 'Counter', importBase: '@animica/sdk' })
 *   fs.writeFileSync('Counter.ts', src)
 */

import type { ABI, ABIItem, ABIFunction, ABIParam } from '../types/abi'

export interface CodegenOptions {
  /** Class name to emit (default inferred from ABI.title or 'ContractClient'). */
  className?: string
  /** Base module path for imports inside the generated file (default '@animica/sdk'). */
  importBase?: string
  /** Optional default address helper export (purely convenience for apps). */
  defaultAddress?: string
  /** Indentation characters (default two spaces). */
  indent?: string
}

/** Generate TypeScript client stub source from an ABI JSON object. */
export function generateContractClientTS(abi: ABI, opts: CodegenOptions = {}): string {
  const importBase = opts.importBase ?? '@animica/sdk'
  const indent = opts.indent ?? '  '
  const className = sanitizeClassName(
    opts.className ?? inferClassName(abi) ?? 'ContractClient'
  )

  const fns = (abi as ABIItem[]).filter((x) => (x as any).type === 'function') as ABIFunction[]
  const events = (abi as ABIItem[]).filter((x) => (x as any).type === 'event')

  // Header & imports
  let out = ''
  out += `/* eslint-disable */\n`
  out += `// Auto-generated by @animica/sdk codegen. Do not edit by hand.\n\n`
  out += `import { Contract } from '${importBase}/contracts/client'\n`
  out += `import type { CallTxParams } from '${importBase}/contracts/client'\n`
  out += `import type { RpcClient, WaitOpts } from '${importBase}/tx/send'\n`
  out += `import type { UnsignedTx } from '${importBase}/tx/build'\n`
  out += `import { matchAndDecodeLogs } from '${importBase}/contracts/events'\n`
  out += `import type { ChainLog } from '${importBase}/contracts/events'\n`
  out += `import type { ABI } from '${importBase}/types/abi'\n\n`

  // ABI constant
  const abiLiteral = jsonStableStringify(abi, indent)
  out += `export const ABI_JSON = ${abiLiteral} as const satisfies ABI\n\n`

  // Arg type aliases & helpers per function
  for (const fn of fns) {
    const methodName = methodIdent(fn.name)
    const tupleType = tupleTypeFor(fn.inputs)
    const namedType = namedTypeFor(fn.inputs)
    out += `export type ${methodName}Args = ${tupleType}\n`
    out += `export interface ${methodName}NamedArgs ${namedType}\n`
    out += helperToArray(methodName, fn.inputs, indent) + '\n'
  }

  // Event topics bag
  out += generateEventTopics(events, indent) + '\n'

  // Class header
  out += `export class ${className} extends Contract {\n`
  out += `${indent}static readonly abi = ABI_JSON\n`
  out += `${indent}constructor(address: string) { super(address, ABI_JSON) }\n\n`

  // Methods per function
  for (const fn of fns) {
    out += generateMethodBlock(fn, indent)
  }

  // decodeEvents helper
  out += `${indent}/** Decode and filter logs using this contract's ABI (optional address filter). */\n`
  out += `${indent}decodeEvents(logs: ChainLog[], opts?: { address?: string }) {\n`
  out += `${indent}${indent}return matchAndDecodeLogs(logs, ABI_JSON, { address: opts?.address })\n`
  out += `${indent}}\n`

  // Optional default address
  if (opts.defaultAddress) {
    out += `\n${indent}/** Optional default address baked into this build. */\n`
    out += `${indent}static readonly defaultAddress = ${JSON.stringify(opts.defaultAddress)}\n`
  }

  out += `}\n\n`

  // Convenience factory
  out += `export default ${className}\n`

  return out
}

// ──────────────────────────────────────────────────────────────────────────────
// Generators
// ──────────────────────────────────────────────────────────────────────────────

function generateMethodBlock(fn: ABIFunction, indent: string): string {
  const name = methodIdent(fn.name)
  const txKind = 'call' as const
  const buildName = `build${capitalize(name)}Tx`

  const argNames = (fn.inputs ?? []).map((p, i) => p.name || `arg${i}`)
  const argArrayExpr = `${name}ArgsToArray(args)`

  let s = ''
  // Builder
  s += `${indent}/** Build unsigned tx for \`${fn.name}(${sigTypes(fn.inputs).join(',')})\`. */\n`
  s += `${indent}${buildName}(args: ${name}Args | ${name}NamedArgs, p: CallTxParams): UnsignedTx {\n`
  s += `${indent}${indent}const data = this.encode(${JSON.stringify(fn.name)}, ${argArrayExpr})\n`
  s += `${indent}${indent}return require('../tx/build').buildCall({\n`
  s += `${indent}${indent}${indent}chainId: p.chainId,\n`
  s += `${indent}${indent}${indent}from: p.from,\n`
  s += `${indent}${indent}${indent}to: this.address,\n`
  s += `${indent}${indent}${indent}data,\n`
  s += `${indent}${indent}${indent}value: p.value,\n`
  s += `${indent}${indent}${indent}nonce: p.nonce,\n`
  s += `${indent}${indent}${indent}gasPrice: p.gasPrice,\n`
  s += `${indent}${indent}${indent}gasLimit: p.gasLimit ?? (require('../tx/build').estimateIntrinsicGas('${txKind}', data.length, p.accessList) * 12n / 10n),\n`
  s += `${indent}${indent}${indent}accessList: p.accessList\n`
  s += `${indent}${indent}})\n`
  s += `${indent}}\n\n`

  // Sender
  s += `${indent}/** Build → sign → send → wait receipt for \`${fn.name}\`. */\n`
  s += `${indent}async ${name}(\n`
  s += `${indent}${indent}client: RpcClient,\n`
  s += `${indent}${indent}signer: { getPublicKey(): Promise<Uint8Array> | Uint8Array; sign(data: Uint8Array, domain?: Uint8Array): Promise<Uint8Array> | Uint8Array; alg: any },\n`
  s += `${indent}${indent}args: ${name}Args | ${name}NamedArgs,\n`
  s += `${indent}${indent}p: CallTxParams,\n`
  s += `${indent}${indent}wait: WaitOpts = {}\n`
  s += `${indent}) {\n`
  s += `${indent}${indent}const tx = this.${buildName}(args, p)\n`
  s += `${indent}${indent}return require('../tx/send').signSendAndWait(client, tx, signer, wait)\n`
  s += `${indent}}\n\n`

  // Encode-only convenience
  s += `${indent}/** Encode call data bytes for \`${fn.name}\`. */\n`
  s += `${indent}encode${capitalize(name)}(args: ${name}Args | ${name}NamedArgs): Uint8Array {\n`
  s += `${indent}${indent}return this.encode(${JSON.stringify(fn.name)}, ${argArrayExpr})\n`
  s += `${indent}}\n\n`

  return s
}

function generateEventTopics(events: ABIItem[], indent: string): string {
  // topic0 = sha3_256("Name(type,...)") — we expose signatures; actual hashing is done at runtime decoders
  let s = `/** Event signatures (topic0 = sha3_256(signature)). */\n`
  s += `export const EventSignatures = {\n`
  const lines: string[] = []
  for (const ev of events) {
    const name = (ev as any).name || 'Event'
    const sig = `${name}(${sigTypes((ev as any).inputs).join(',')})`
    lines.push(`${indent}${JSON.stringify(name)}: ${JSON.stringify(sig)}`)
  }
  s += lines.join(',\n') + '\n'
  s += `} as const\n\n`
  s += `export type EventName = keyof typeof EventSignatures\n`
  return s
}

// ──────────────────────────────────────────────────────────────────────────────
/* Helpers */
// ──────────────────────────────────────────────────────────────────────────────

function inferClassName(abi: any): string | undefined {
  const title = (abi as any)?.title || (abi as any)?.contractName
  if (typeof title === 'string' && title.trim()) return sanitizeClassName(title.trim())
  return undefined
}

function sanitizeClassName(x: string): string {
  const s = x.replace(/[^A-Za-z0-9_]/g, ' ').trim().split(/\s+/).map(capitalize).join('')
  return /^[A-Za-z_]/.test(s) ? s : `C${s}`
}

function capitalize(s: string): string {
  return s ? s[0].toUpperCase() + s.slice(1) : s
}

function methodIdent(name: string | undefined): string {
  if (!name || !name.trim()) return 'method'
  const base = name.replace(/[^A-Za-z0-9_]/g, '_')
  const camel = base.replace(/_+(\w)/g, (_, c) => (c || '').toUpperCase())
  const s = camel[0].toLowerCase() + camel.slice(1)
  return /^[A-Za-z_]/.test(s) ? s : `m_${s}`
}

function sigTypes(params: ABIParam[] | undefined): string[] {
  return (params ?? []).map((p) => p.type || 'unknown')
}

function tupleTypeFor(params: ABIParam[] | undefined): string {
  const types = (params ?? []).map((p) => tsTypeFor(p))
  return `[${types.join(', ')}]`
}

function namedTypeFor(params: ABIParam[] | undefined): string {
  const items = (params ?? []).map((p, i) => {
    const name = p.name && /^[A-Za-z_]\w*$/.test(p.name) ? p.name : `arg${i}`
    return `${name}: ${tsTypeFor(p)}`
  })
  return `{ ${items.join('; ')} }`
}

function tsTypeFor(p: ABIParam): string {
  const t = p.type || 'unknown'
  // Array types: foo[] or foo[n]
  const arrayMatch = t.match(/^(.*)\[(.*?)\]$/)
  if (arrayMatch) {
    const inner = { ...p, type: arrayMatch[1] }
    return `${tsTypeFor(inner)}[]`
  }
  if (t === 'address') return 'string'
  if (t === 'bool') return 'boolean'
  if (t === 'string') return 'string'
  if (t === 'bytes' || /^bytes\d+$/.test(t)) return 'Uint8Array | string'
  if (/^(u?int)(\d+)?$/.test(t)) return 'bigint | number | string'
  if (t.startsWith('tuple')) {
    // If components present, map to object type; else fallback to unknown[]
    const comps = (p as any).components as ABIParam[] | undefined
    if (Array.isArray(comps) && comps.length > 0) {
      const fields = comps.map((c, i) => {
        const name = c.name && /^[A-Za-z_]\w*$/.test(c.name) ? c.name : `f${i}`
        return `${name}: ${tsTypeFor(c)}`
      })
      return `{ ${fields.join('; ')} }`
    }
    return 'unknown[]'
  }
  return 'unknown'
}

function helperToArray(methodName: string, params: ABIParam[], indent: string): string {
  const picks = params.map((p, i) => (p.name && /^[A-Za-z_]\w*$/.test(p.name)) ? p.name : `arg${i}`)
  let s = `function ${methodName}ArgsToArray(args: ${methodName}Args | ${methodName}NamedArgs): unknown[] {\n`
  s += `${indent}if (Array.isArray(args)) return args as unknown[]\n`
  if (picks.length === 0) {
    s += `${indent}return []\n`
  } else {
    s += `${indent}return [${picks.map((n) => `args.${n}`).join(', ')}]\n`
  }
  s += `}\n`
  return s
}

function jsonStableStringify(x: any, indent: string): string {
  const seen = new WeakSet()
  const replacer = (_k: string, v: any) => {
    if (v && typeof v === 'object') {
      if (seen.has(v)) return
      seen.add(v)
      if (!Array.isArray(v)) {
        const o: Record<string, any> = {}
        for (const k of Object.keys(v).sort()) o[k] = v[k]
        return o
      }
    }
    return v
  }
  return JSON.stringify(x, replacer, indent)
}

export default {
  generateContractClientTS
}
