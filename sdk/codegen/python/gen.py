from __future__ import annotations

"""
Python Codegen — Emit Contract Client Stubs
===========================================

This module turns a normalized ABI (see sdk.codegen.common.normalize) into a
production-ready Python client class that subclasses
`omni_sdk.contracts.client.ContractClient`.

The generated client:

- Embeds the canonical ABI JSON (already normalized) as `ABI`.
- Exposes one method per function. Read-only (`view`/`pure`) map to `call`,
  mutating (`nonpayable`/`payable`) map to `transact`.
- Derives precise Python type hints for parameters and return values.
- Disambiguates overloaded names by appending a short discriminator suffix.
- Exposes `SELECTORS` and `TOPICS` dicts for functions/events.
- Includes rich docstrings with canonical signatures and selectors.

Primary entrypoint: `render_client(abi, class_name="MyContract") -> str`.
"""

from dataclasses import asdict
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple, Union
import json
import keyword
import textwrap

from sdk.codegen.common.normalize import (
    normalize_abi,
    AbiNormalizationError,
)
from sdk.codegen.common.model import (
    AbiIR,
    FunctionIR,
    EventIR,
    ErrorIR,
    TypeRef,
    Param,
)


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

def render_client(
    abi: Union[str, Dict[str, Any], AbiIR],
    *,
    class_name: str = "ContractClientStub",
    base_import: str = "omni_sdk.contracts.client",
    base_class: str = "ContractClient",
    call_method: str = "call",
    transact_method: str = "transact",
    address_type: str = "str",  # bech32m address string ("anim1...")
) -> str:
    """
    Render a Python module containing a single client class.

    Args:
        abi: Raw ABI (JSON string or dict) or an already-normalized AbiIR.
        class_name: Name of the generated class.
        base_import: Import path of the base client class.
        base_class: Name of the base client class at that import.
        call_method: Read-only invocation method name on the base class.
        transact_method: Mutating invocation method name on the base class.
        address_type: Type hint used for contract address.

    Returns:
        Python source code as a string.
    """
    abi_ir = _to_ir(abi)

    # Build module text
    lines: List[str] = []
    w = lines.append

    w("# This file was generated by sdk.codegen.python.gen.render_client")
    w("# Do not edit by hand. Edit ABI or templates and re-generate.\n")
    w("from __future__ import annotations\n")
    w("from typing import Any, Optional, List, Tuple, Dict\n")
    w("import json\n")
    w(f"from {base_import} import {base_class}\n")
    w("\n")
    w(f"ABI: Dict[str, Any] = json.loads(r'''{_embed_json(abi_ir)}''')\n")
    w(_emit_selectors_topics(abi_ir))
    w("\n")
    w(_emit_class_header(class_name, base_class, address_type))
    w(textwrap.indent(_emit_init_body(class_name), "    "))
    w("\n")
    for fn in abi_ir.functions:
        w(textwrap.indent(_emit_function_method(fn, call_method, transact_method), "    "))
        w("")
    # Event helpers (lightweight: just topic IDs as constants dict)
    w(textwrap.indent(_emit_event_helpers(), "    "))
    w("\n")
    return "\n".join(lines)


# ---------------------------------------------------------------------------
# Internals
# ---------------------------------------------------------------------------

def _to_ir(abi: Union[str, Dict[str, Any], AbiIR]) -> AbiIR:
    if isinstance(abi, AbiIR):
        return abi
    return normalize_abi(abi)


def _embed_json(abi_ir: AbiIR) -> str:
    """Return a compact JSON string safe to embed inside a triple-quoted literal."""
    payload = abi_ir.to_dict()
    return json.dumps(payload, separators=(",", ":"), ensure_ascii=False)


def _emit_selectors_topics(abi_ir: AbiIR) -> str:
    f_map = ",\n    ".join(
        [f"'{_method_name(fn)}': '{fn.selector}'" for fn in abi_ir.functions]
    )
    e_map = ",\n    ".join(
        [f"'{_event_name(ev)}': '{ev.topic_id}'" for ev in abi_ir.events]
    )
    body = [
        "SELECTORS: Dict[str, str] = {",
        f"    {f_map}",
        "}\n",
        "TOPICS: Dict[str, str] = {",
        f"    {e_map}",
        "}\n",
    ]
    return "\n".join(body)


def _emit_class_header(class_name: str, base_class: str, address_type: str) -> str:
    return textwrap.dedent(
        f"""
        class {class_name}({base_class}):
            \"\"\"Strongly-typed client for this contract.

            Attributes
            ----------
            ABI : dict
                Canonical ABI used by this client.
            SELECTORS : dict[str, str]
                Function name → sha3-256 selector hex.
            TOPICS : dict[str, str]
                Event name → sha3-256 topic-id hex.
            \"\"\"
        """
    ).rstrip()


def _emit_init_body(class_name: str) -> str:
    return textwrap.dedent(
        """
        def __init__(
            self,
            address: str,
            *,
            rpc_url: Optional[str] = None,
            chain_id: Optional[int] = None,
            signer: Any = None,
            http_client: Any = None,
        ) -> None:
            \"\"\"Create a client bound to `address`.

            Parameters
            ----------
            address:
                Contract address (bech32m anim1… or canonical address).
            rpc_url:
                RPC endpoint URL. If omitted, the base class default is used.
            chain_id:
                Optional chain-id override for signing.
            signer:
                Optional signer compatible with the base client.
            http_client:
                Optional http client (requests/httpx-like) used by the base client.
            \"\"\"
            super().__init__(
                address=address,
                abi=ABI,
                rpc_url=rpc_url,
                chain_id=chain_id,
                signer=signer,
                http_client=http_client,
            )
        """
    ).rstrip()


def _emit_function_method(fn: FunctionIR, call_method: str, transact_method: str) -> str:
    name = _method_name(fn)
    py_sig = _py_signature(fn)
    doc = _fn_docstring(fn)

    # Decide invocation style
    is_view = fn.state_mutability in ("view", "pure")
    invoke = call_method if is_view else transact_method

    args_list = ", ".join(p.name for p in fn.inputs) or ""
    if args_list:
        args_expr = f"[{args_list}]"
    else:
        args_expr = "[]"

    # Return typing
    rtn_hint = _return_type_hint(fn)
    # Unwrap if ABI reports 0 outputs but view: still return whatever base returns (likely Any)
    # For transactions, we return whatever base returns (dict receipt / hash)
    body = textwrap.dedent(
        f"""
        def {name}(self, {py_sig}) -> {rtn_hint}:
            \"\"\"{doc}\"\"\"
            return self.{invoke}("{fn.name}", [{_args_for_call(fn)}])
        """
    ).rstrip()
    return body


def _emit_event_helpers() -> str:
    return textwrap.dedent(
        """
        # --- Event helpers ---
        @property
        def event_topics(self) -> Dict[str, str]:
            \"\"\"Expose event topic IDs (name → topic hex).\"\"\"
            return TOPICS
        """
    ).rstrip()


# ---------------------------------------------------------------------------
# Rendering helpers
# ---------------------------------------------------------------------------

def _method_name(fn: FunctionIR) -> str:
    """
    Python-safe method name. If an overload discriminator is present, append it.
    """
    base = _py_ident(fn.name)
    if fn.discriminator:
        return f"{base}_{fn.discriminator}"
    return base


def _event_name(ev: EventIR) -> str:
    base = _py_ident(ev.name)
    if ev.discriminator:
        return f"{base}_{ev.discriminator}"
    return base


def _py_ident(name: str) -> str:
    safe = "".join(ch if (ch.isalnum() or ch == "_") else "_" for ch in name.strip())
    if not safe:
        safe = "_unnamed"
    if safe[0].isdigit():
        safe = "_" + safe
    if keyword.iskeyword(safe):
        safe = safe + "_"
    return safe


def _py_type_hint(t: TypeRef) -> str:
    k = t.kind
    if k in ("uint", "int"):
        return "int"
    if k == "bool":
        return "bool"
    if k == "bytes":
        # fixed or dynamic — always bytes at Python boundary
        return "bytes"
    if k == "string":
        return "str"
    if k == "address":
        return "str"
    if k == "array":
        inner = _py_type_hint(_assert(t.array_item))
        return f"List[{inner}]"
    if k == "tuple":
        elems = t.tuple_elems or []
        if not elems:
            return "Tuple[()]"
        inner = ", ".join(_py_type_hint(e) for e in elems)
        if len(elems) == 1:
            inner += ","
        return f"Tuple[{inner}]"
    return "Any"


def _return_type_hint(fn: FunctionIR) -> str:
    outs = fn.outputs
    if fn.state_mutability in ("view", "pure"):
        if not outs:
            return "Any"
        if len(outs) == 1:
            return _py_type_hint(outs[0])
        inner = ", ".join(_py_type_hint(t) for t in outs)
        return f"Tuple[{inner}]"
    # For mutating txs, let the base decide (usually a Receipt dict)
    return "Any"


def _py_signature(fn: FunctionIR) -> str:
    # parameters only; no **kwargs to keep API strict
    parts: List[str] = []
    for p in fn.inputs:
        parts.append(f"{_py_ident(p.name)}: {_py_type_hint(p.type)}")
    return ", ".join(parts)


def _args_for_call(fn: FunctionIR) -> str:
    return ", ".join(_py_ident(p.name) for p in fn.inputs)


def _fn_docstring(fn: FunctionIR) -> str:
    ins = ", ".join(f"{p.name}:{p.type.canonical_str()}" for p in fn.inputs) or "—"
    outs = ", ".join(t.canonical_str() for t in fn.outputs) or "—"
    kind = fn.state_mutability
    selector = fn.selector
    sig = fn.signature
    return (
        f"{fn.name} {kind}\n\n"
        f"Signature: ``{sig}``\n"
        f"Selector: ``{selector}``\n"
        f"Inputs: {ins}\n"
        f"Returns: {outs}"
    )


def _assert(x: Optional[Any]) -> Any:
    if x is None:
        raise RuntimeError("unexpected None")
    return x


# ---------------------------------------------------------------------------
# CLI convenience (optional)
# ---------------------------------------------------------------------------

def render_client_from_file(
    abi_path: str,
    *,
    class_name: str = "ContractClientStub",
    **kwargs: Any,
) -> str:
    """
    Convenience helper for out-of-tree usage. Loads ABI JSON from path and renders.
    """
    with open(abi_path, "r", encoding="utf-8") as f:
        raw = json.load(f)
    return render_client(raw, class_name=class_name, **kwargs)


if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser(description="Render a Python contract client from ABI JSON.")
    ap.add_argument("abi_json", help="Path to ABI JSON file")
    ap.add_argument("--class", dest="class_name", default="ContractClient", help="Generated class name")
    ap.add_argument("--base-import", dest="base_import", default="omni_sdk.contracts.client")
    ap.add_argument("--base-class", dest="base_class", default="ContractClient")
    args = ap.parse_args()

    code = render_client_from_file(
        args.abi_json,
        class_name=args.class_name,
        base_import=args.base_import,
        base_class=args.base_class,
    )
    print(code)
