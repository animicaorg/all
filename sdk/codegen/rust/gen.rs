//! Rust Codegen — Emit Contract Client Stubs
//! ========================================
//!
//! Turns a normalized ABI IR (see repo docs) into a typed Rust client
//! that wraps `animica_sdk::contracts::client::ContractClient`.
//!
//! The input ABI must already be *normalized*:
//! - functions/events/errors include `signature`, `selector`/`topic_id`
//! - types are canonicalized; overloads may use `discriminator`
//!
//! Programmatic usage:
//! ```ignore
//! let code = render_client(abi_json, RenderOptions{ class_name: Some("Counter".into()), ..Default::default() });
//! ```
//!
//! CLI usage (when compiled as a binary):
//! ```bash
//! cargo run -p codegen -- sdk/common/examples/counter_abi.json --class Counter
//! # prints code to stdout
//! ```

use std::fmt::Write as _;
use std::fs;
use std::path::Path;

use serde::{Deserialize, Serialize};
use serde_json::Value as Json;

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(rename_all = "snake_case")]
pub struct TypeRef {
    pub kind: String,                          // 'uint' | 'int' | 'bytes' | 'bool' | 'address' | 'string' | 'array' | 'tuple'
    pub bits: Option<u32>,                     // for int/uint, bytesN (bits)
    pub array_item: Option<Box<TypeRef>>,      // for array
    pub array_len: Option<u32>,                // optional fixed length
    pub tuple_elems: Option<Vec<TypeRef>>,     // for tuple
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ParamIR {
    pub name: String,
    pub r#type: TypeRef,
    #[serde(default)]
    pub indexed: bool,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(rename_all = "snake_case")]
pub struct FunctionIR {
    pub name: String,
    pub inputs: Vec<ParamIR>,
    pub outputs: Vec<TypeRef>,
    pub state_mutability: String, // 'pure' | 'view' | 'nonpayable' | 'payable'
    pub signature: String,
    pub selector: String,
    pub discriminator: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct EventIR {
    pub name: String,
    pub inputs: Vec<ParamIR>,
    pub signature: String,
    pub topic_id: String,
    pub discriminator: Option<String>,
    #[serde(default)]
    pub anonymous: bool,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ErrorIR {
    pub name: String,
    pub inputs: Vec<ParamIR>,
    pub signature: String,
    pub selector: String,
    pub discriminator: Option<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct AbiIR {
    pub functions: Vec<FunctionIR>,
    pub events: Vec<EventIR>,
    #[serde(default)]
    pub errors: Vec<ErrorIR>,
    #[serde(default)]
    pub metadata: Json,
}

#[derive(Debug, Clone, Default)]
pub struct RenderOptions {
    pub class_name: Option<String>,      // default: ContractClientStub
    pub base_path: Option<String>,       // default: animica_sdk::contracts::client
    pub base_class: Option<String>,      // default: ContractClient
    pub address_type: Option<String>,    // default: String (bech32m)
}

/// Render a Rust module exporting a single strongly-typed client struct.
///
/// The generated client wraps `animica_sdk::contracts::client::ContractClient`
/// and exposes one async method per function in the ABI IR.
pub fn render_client(abi: impl AsRef<str>, opts: RenderOptions) -> String {
    let ir: AbiIR = serde_json::from_str(abi.as_ref())
        .expect("ABI IR must be valid JSON and match schema");

    validate_ir(&ir);

    let class_name = opts.class_name.unwrap_or_else(|| "ContractClientStub".into());
    let base_path = opts
        .base_path
        .unwrap_or_else(|| "animica_sdk::contracts::client".into());
    let base_class = opts.base_class.unwrap_or_else(|| "ContractClient".into());
    let addr_ty = opts.address_type.unwrap_or_else(|| "String".into());

    let mut out = String::new();

    // Header & imports
    writeln!(
        out,
        "//! This file was generated by Animica SDK codegen (Rust). Do not edit by hand.\n"
    )
    .unwrap();
    writeln!(out, "use {base_path}::{base_class};").unwrap();
    writeln!(out, "use serde::de::DeserializeOwned;").unwrap();
    writeln!(out, "use serde_json::Value as Json;").unwrap();
    writeln!(out, "use std::collections::BTreeMap;").unwrap();
    writeln!(out, "use std::borrow::Cow;").unwrap();
    writeln!(out).unwrap();

    // Embed ABI JSON (compact)
    let abi_json = serde_json::to_string(&ir_to_plain(&ir)).expect("serialize");
    writeln!(
        out,
        "pub static ABI_JSON: &str = r#\"{}\"#;",
        abi_json.replace("\"", "\\\"")
    )
    .unwrap();
    writeln!(out, "pub fn abi_json() -> &'static str {{ ABI_JSON }}").unwrap();
    writeln!(out, "pub fn abi_value() -> Json {{ serde_json::from_str(ABI_JSON).expect(\"ABI_JSON\") }}").unwrap();
    writeln!(out).unwrap();

    // SELECTORS / TOPICS
    writeln!(
        out,
        "pub fn selectors() -> BTreeMap<&'static str, &'static str> {{"
    )
    .unwrap();
    writeln!(out, "  let mut m = BTreeMap::new();").unwrap();
    for f in &ir.functions {
        writeln!(
            out,
            "  m.insert({}, {});",
            rs_str(&method_name(f)),
            rs_str(&f.selector)
        )
        .unwrap();
    }
    writeln!(out, "  m").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out).unwrap();

    writeln!(
        out,
        "pub fn topics() -> BTreeMap<&'static str, &'static str> {{"
    )
    .unwrap();
    writeln!(out, "  let mut m = BTreeMap::new();").unwrap();
    for e in &ir.events {
        writeln!(
            out,
            "  m.insert({}, {});",
            rs_str(&event_name(e)),
            rs_str(&e.topic_id)
        )
        .unwrap();
    }
    writeln!(out, "  m").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out).unwrap();

    // Struct header / constructor
    writeln!(out, "#[derive(Clone)]").unwrap();
    writeln!(out, "pub struct {class_name} {{").unwrap();
    writeln!(out, "  inner: {base_class},").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out).unwrap();

    writeln!(out, "impl {class_name} {{").unwrap();
    writeln!(out, "  /// Create a client bound to `address`.").unwrap();
    writeln!(
        out,
        "  pub fn new(address: {addr_ty}, opts: Option<{}::Options>) -> Self {{",
        base_path
    )
    .unwrap();
    writeln!(
        out,
        "    let inner = {base_class}::new(address, abi_value(), opts);"
    )
    .unwrap();
    writeln!(out, "    Self {{ inner }}").unwrap();
    writeln!(out, "  }}").unwrap();
    writeln!(out).unwrap();

    // Method helpers to expose inner
    writeln!(
        out,
        "  #[inline] pub fn address(&self) -> &str {{ self.inner.address() }}"
    )
    .unwrap();
    writeln!(
        out,
        "  #[inline] pub fn set_signer(&mut self, signer: Option<{}::Signer>) {{ self.inner.set_signer(signer) }}",
        base_path
    )
    .unwrap();
    writeln!(out).unwrap();

    // Functions
    for f in &ir.functions {
        let sig = fn_params_sig(f);
        let ret_ty = rs_return_ty(f);
        let doc = fn_doc(f);
        let is_view = f.state_mutability == "view" || f.state_mutability == "pure";
        let inv = if is_view { "call" } else { "transact" };
        let args_vec = format!("[{}]", args_for_call(f));

        writeln!(out, "  {}", doc_comment(&doc)).unwrap();
        writeln!(
            out,
            "  pub async fn {}(&self, {}) -> Result<{}, {}::Error> {{",
            method_name(f),
            sig,
            ret_ty,
            base_path
        )
        .unwrap();

        if is_view {
            writeln!(
                out,
                "    self.inner.{inv}::<{ret_ty}>({}, serde_json::json!({args_vec})).await"
            ,
                rs_str(&f.name)
            )
            .unwrap();
        } else {
            // Mutating txs: defer to base; return opaque Json (tx hash/receipt depending on call site).
            writeln!(
                out,
                "    self.inner.{inv}::<{ret_ty}>({}, serde_json::json!({args_vec})).await",
                rs_str(&f.name)
            )
            .unwrap();
        }

        writeln!(out, "  }}").unwrap();
        writeln!(out).unwrap();
    }

    // Event topics helper
    writeln!(
        out,
        "  /// Expose event topic IDs (name → topic hex)."
    )
    .unwrap();
    writeln!(
        out,
        "  pub fn event_topics(&self) -> BTreeMap<&'static str, &'static str> {{ topics() }}"
    )
    .unwrap();

    writeln!(out, "}}").unwrap();
    writeln!(out).unwrap();

    out
}

// ------------------------------ helpers -----------------------------------

fn validate_ir(ir: &AbiIR) {
    assert!(
        !ir.functions.is_empty(),
        "ABI IR must contain at least one function"
    );
    for f in &ir.functions {
        assert!(
            !f.signature.is_empty() && !f.selector.is_empty(),
            "Function {} missing signature/selector; ensure ABI is normalized",
            f.name
        );
    }
    for e in &ir.events {
        assert!(
            !e.signature.is_empty() && !e.topic_id.is_empty(),
            "Event {} missing signature/topic_id; ensure ABI is normalized",
            e.name
        );
    }
}

fn ir_to_plain(ir: &AbiIR) -> Json {
    serde_json::to_value(ir).expect("to_value")
}

fn rs_str(s: &str) -> String {
    let escaped = s.replace('\\', "\\\\").replace('\"', "\\\"");
    format!("\"{}\"", escaped)
}

fn rs_ident(name: &str) -> String {
    let mut out = String::new();
    let mut chars = name.trim().chars().peekable();
    if let Some(c0) = chars.peek() {
        if c0.is_ascii_digit() {
            out.push('_');
        }
    }
    while let Some(c) = chars.next() {
        if c.is_ascii_alphanumeric() || c == '_' {
            out.push(c);
        } else {
            out.push('_');
        }
    }
    if is_rs_keyword(&out) {
        out.push('_');
    }
    if out.is_empty() {
        "_unnamed".into()
    } else {
        out
    }
}

fn is_rs_keyword(s: &str) -> bool {
    matches!(
        s,
        "as"|"break"|"const"|"continue"|"crate"|"else"|"enum"|"extern"|"false"|"fn"|"for"|"if"|
        "impl"|"in"|"let"|"loop"|"match"|"mod"|"move"|"mut"|"pub"|"ref"|"return"|"self"|"Self"|
        "static"|"struct"|"super"|"trait"|"true"|"type"|"unsafe"|"use"|"where"|"while"|
        // 2018/2021 edition keywords/reserved
        "async"|"await"|"dyn"|"abstract"|"become"|"box"|"do"|"final"|"macro"|"override"|
        "priv"|"typeof"|"unsized"|"virtual"|"yield"|"try"
    )
}

fn method_name(f: &FunctionIR) -> String {
    if let Some(dis) = &f.discriminator {
        format!("{}_{}", rs_ident(&f.name), rs_ident(dis))
    } else {
        rs_ident(&f.name)
    }
}

fn event_name(e: &EventIR) -> String {
    if let Some(dis) = &e.discriminator {
        format!("{}_{}", rs_ident(&e.name), rs_ident(dis))
    } else {
        rs_ident(&e.name)
    }
}

fn rs_scalar_ty(kind: &str, bits: Option<u32>, signed: bool) -> &'static str {
    // Prefer native up to 128-bits; beyond that fall back to String for now.
    match (kind, bits.unwrap_or(256)) {
        ("int", b) | ("uint", b) if b <= 8 => if signed { "i8" } else { "u8" },
        ("int", b) | ("uint", b) if b <= 16 => if signed { "i16" } else { "u16" },
        ("int", b) | ("uint", b) if b <= 32 => if signed { "i32" } else { "u32" },
        ("int", b) | ("uint", b) if b <= 64 => if signed { "i64" } else { "u64" },
        ("int", b) | ("uint", b) if b <= 128 => if signed { "i128" } else { "u128" },
        _ => "String", // safe, RPC will encode as hex/decimal string; callers can parse as needed
    }
}

fn rs_ty(t: &TypeRef) -> String {
    match t.kind.as_str() {
        "uint" => rs_scalar_ty("uint", t.bits, false).into(),
        "int" => rs_scalar_ty("int", t.bits, true).into(),
        "bool" => "bool".into(),
        "string" => "String".into(),
        "address" => "String".into(),
        "bytes" => "Vec<u8>".into(),
        "array" => {
            let inner = t
                .array_item
                .as_ref()
                .map(|b| rs_ty(b))
                .unwrap_or_else(|| "serde_json::Value".into());
            format!("Vec<{}>", inner)
        }
        "tuple" => {
            let elems = t.tuple_elems.as_ref().map(|v| v.clone()).unwrap_or_default();
            if elems.is_empty() {
                "()".into()
            } else {
                let parts: Vec<String> = elems.iter().map(rs_ty).collect();
                format!("({})", parts.join(", "))
            }
        }
        _ => "serde_json::Value".into(),
    }
}

fn rs_return_ty(f: &FunctionIR) -> String {
    let is_view = f.state_mutability == "view" || f.state_mutability == "pure";
    if !is_view {
        // Mutating tx: base returns generic T; use Json unless caller specializes.
        return "Json".into();
    }
    match f.outputs.len() {
        0 => "Json".into(),
        1 => rs_ty(&f.outputs[0]),
        _ => {
            let parts: Vec<String> = f.outputs.iter().map(rs_ty).collect();
            format!("({})", parts.join(", "))
        }
    }
}

fn fn_params_sig(f: &FunctionIR) -> String {
    f.inputs
        .iter()
        .map(|p| format!("{}: {}", rs_ident(&p.name), rs_ty(&p.r#type)))
        .collect::<Vec<_>>()
        .join(", ")
}

fn args_for_call(f: &FunctionIR) -> String {
    f.inputs
        .iter()
        .map(|p| rs_ident(&p.name))
        .collect::<Vec<_>>()
        .join(", ")
}

fn fn_doc(f: &FunctionIR) -> String {
    let ins = if f.inputs.is_empty() {
        "—".into()
    } else {
        f.inputs
            .iter()
            .map(|p| format!("{}:{:?}", p.name, p.r#type.kind))
            .collect::<Vec<_>>()
            .join(", ")
    };
    let outs = if f.outputs.is_empty() {
        "—".into()
    } else {
        f.outputs
            .iter()
            .map(|t| t.kind.clone())
            .collect::<Vec<_>>()
            .join(", ")
    };
    format!(
        "{} {}\nSignature: {}\nSelector: {}\nInputs: {}\nReturns: {}",
        f.name, f.state_mutability, f.signature, f.selector, ins, outs
    )
}

fn doc_comment(doc: &str) -> String {
    let mut s = String::new();
    for line in doc.lines() {
        let _ = writeln!(s, "/// {}", line);
    }
    s
}

// ------------------------------- CLI --------------------------------------

fn main() {
    // Simple CLI: gen.rs <abi.json> [--class Name]
    let mut args = std::env::args().skip(1).collect::<Vec<_>>();
    if args.is_empty() {
        eprintln!("Usage: gen.rs <abi.json> [--class Name]");
        eprintln!("       prints generated Rust code to stdout");
        return;
    }
    let abi_path = args.remove(0);
    let mut class_name: Option<String> = None;
    let mut i = 0;
    while i < args.len() {
        if args[i] == "--class" && i + 1 < args.len() {
            class_name = Some(args[i + 1].clone());
            i += 2;
        } else {
            i += 1;
        }
    }

    let raw = fs::read_to_string(Path::new(&abi_path))
        .expect("failed to read ABI json file");
    let code = render_client(
        raw,
        RenderOptions {
            class_name: class_name.or(Some("ContractClient".into())),
            base_path: None,
            base_class: None,
            address_type: None,
        },
    );
    print!("{code}");
}
