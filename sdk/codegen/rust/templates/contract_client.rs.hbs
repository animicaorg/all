//! This file was generated by Animica SDK codegen (Rust, Handlebars template).
//! Do not edit by hand.
//
// Expected context (normalized ABI IR):
// {
//   "class_name": "Counter",
//   "base_path": "animica_sdk::contracts::client",
//   "base_class": "ContractClient",
//   "address_type": "String",                 // optional; defaults to "String" (bech32m)
//   "abi": { ... },                           // full normalized ABI object
//   "functions": [
//      {
//        "name": "inc",
//        "method_name": "inc",                // optional precomputed safe ident (with discriminator)
//        "signature": "inc()",
//        "selector": "0x…",
//        "state_mutability": "nonpayable",    // or "view"/"pure"
//        "inputs": [ { "name": "n", "type": { /* … */ }, "rs_type": "u64" } ],
//        "outputs": [ { "kind":"uint", "bits":256, "rs_type":"String" } ],
//        "return_rs": "String"                // optional precomputed return type
//      }
//   ],
//   "events": [
//      {
//        "name": "Incremented",
//        "method_name": "Incremented",
//        "signature": "Incremented(uint256)",
//        "topic_id": "0x…",
//        "inputs": [ { "name": "value", "indexed": true, "type": { /* … */ } } ]
//      }
//   ]
// }
//
// Recommended helpers (register in your codegen driver):
//  - ident: sanitize strings to valid Rust identifiers.
//  - json: JSON.stringify value without HTML escaping.
//  - eq(a,b): boolean equality.
//  - or(a,b): boolean or.
//  - coalesce(a,b): returns a if truthy else b.
//  - rsType(type): maps TypeRef → Rust type (fallback to "serde_json::Value").
//  - retType(fn): returns Rust return type for a function (uses outputs/state_mutability).
// If you don't provide rsType/retType, precompute "rs_type" for params and "return_rs" per fn.

// ---------- imports ----------
use {{base_path}}::{{base_class}};
use serde_json::Value as Json;
use std::collections::BTreeMap;

// ---------- embedded ABI ----------
pub static ABI_JSON: &str = r#"{{{json abi}}}"#;

#[inline]
pub fn abi_json() -> &'static str { ABI_JSON }

#[inline]
pub fn abi_value() -> Json { serde_json::from_str(ABI_JSON).expect("ABI_JSON must be valid") }

// ---------- selector / topic tables ----------
pub fn selectors() -> BTreeMap<&'static str, &'static str> {
  let mut m = BTreeMap::new();
  {{#each functions}}
  m.insert({{json (coalesce method_name (ident name))}}, {{json selector}});
  {{/each}}
  m
}

pub fn topics() -> BTreeMap<&'static str, &'static str> {
  let mut m = BTreeMap::new();
  {{#each events}}
  m.insert({{json (coalesce method_name (ident name))}}, {{json topic_id}});
  {{/each}}
  m
}

// ---------- client wrapper ----------
#[derive(Clone)]
pub struct {{class_name}} {
  inner: {{base_class}},
}

impl {{class_name}} {
  /// Create a client bound to `address`.
  pub fn new(address: {{coalesce address_type "String"}}, opts: Option<{{base_path}}::Options>) -> Self {
    let inner = {{base_class}}::new(address, abi_value(), opts);
    Self { inner }
  }

  /// Address this client is bound to.
  #[inline] pub fn address(&self) -> &str { self.inner.address() }

  /// Set or clear the signer used for transactions.
  #[inline] pub fn set_signer(&mut self, signer: Option<{{base_path}}::Signer>) { self.inner.set_signer(signer) }

  /// Expose event topic IDs (name → topic hex).
  #[inline] pub fn event_topics(&self) -> BTreeMap<&'static str, &'static str> { topics() }

  {{#each functions}}
  /// {{name}} {{state_mutability}}
  /// Signature: {{signature}}
  /// Selector:  {{selector}}
  pub async fn {{coalesce method_name (ident name)}}(
    &self,
    {{#each inputs}}
      {{ident name}}: {{coalesce rs_type (rsType type)}}{{#unless @last}},{{/unless}}
    {{/each}}
  ) -> Result<{{coalesce return_rs (retType .)}}, {{base_path}}::Error> {
    {{#if (or (eq state_mutability "view") (eq state_mutability "pure"))}}
    self.inner.call::<{{coalesce return_rs (retType .)}}>(
      {{json name}},
      serde_json::json!([{{#each inputs}}{{ident name}}{{#unless @last}}, {{/unless}}{{/each}}])
    ).await
    {{else}}
    self.inner.transact::<{{coalesce return_rs (retType .)}}>(
      {{json name}},
      serde_json::json!([{{#each inputs}}{{ident name}}{{#unless @last}}, {{/unless}}{{/each}}])
    ).await
    {{/if}}
  }
  {{/each}}
}
