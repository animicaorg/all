/* This file was generated by Animica SDK codegen (TS, Handlebars template).
 * Do not edit by hand.
 *
 * Expected context (normalized ABI IR):
 * {
 *   "class_name": "Counter",
 *   "base_import": "@animica/sdk/contracts/client",
 *   "base_class": "ContractClient",
 *   "abi": { ... },                 // full normalized ABI object
 *   "functions": [
 *      {
 *        "name": "inc",
 *        "discriminator": null,     // optional for overloads
 *        "signature": "inc()",
 *        "selector": "0x…",
 *        "state_mutability": "nonpayable", // or "view"/"pure"
 *        "invoke": "transact",      // optional precomputed; if absent, see note below
 *        "inputs": [ { "name": "n", "type": { /* … */ }, "ts_type": "bigint" } ],
 *        "outputs": [ { "ts_type": "bigint" } ]
 *      }
 *   ],
 *   "events": [
 *      {
 *        "name": "Incremented",
 *        "discriminator": null,
 *        "signature": "Incremented(uint256)",
 *        "topic_id": "0x…",
 *        "inputs": [ { "name": "value", "indexed": true, "type": { /* … */ } } ]
 *      }
 *   ]
 * }
 *
 * Recommended helpers (register in your codegen driver if you use this template directly):
 *  - ident: sanitize strings to valid TS identifiers.
 *  - json: JSON.stringify value.
 *  - eq(a,b): boolean equality.
 *  - coalesce(a,b): returns a if truthy else b.
 *  - tsType(type): maps TypeRef → TS type string (fallback to "any" if absent).
 *  - retType(fn): returns TS return type for function (uses outputs/state_mutability).
 *
 * NOTE: If you don't provide the helpers above, ensure your IR precomputes:
 *  - method_name (safe identifier, with discriminator applied when present)
 *  - param_ts and return_ts strings
 *  - invoke ∈ {"call","transact"} for each function
 */

import type { Abi } from '@animica/sdk/types/abi';
import { {{base_class}} } from '{{base_import}}';

export const ABI: Abi = {{{json abi}}};

export const SELECTORS: Readonly<Record<string, string>> = {
{{#each functions}}
  {{json (coalesce method_name (ident name))}}: {{json selector}}{{#unless @last}},{{/unless}}
{{/each}}
} as const;

export const TOPICS: Readonly<Record<string, string>> = {
{{#each events}}
  {{json (coalesce method_name (ident name))}}: {{json topic_id}}{{#unless @last}},{{/unless}}
{{/each}}
} as const;

export class {{class_name}} extends {{base_class}} {
  /** Create a client bound to `address`. */
  constructor(address: string, opts: Partial<{ rpcUrl: string; chainId: number; signer: any; httpClient: any; }> = {}) {
    // @ts-ignore base class accepts (address, abi, opts)
    super(address, ABI, opts);
  }

{{#each functions}}
  /** {{name}} {{state_mutability}}
   *  Signature: {{signature}}
   *  Selector:  {{selector}}
   */
  async {{coalesce method_name (ident name)}}(
    {{#each inputs}}
      {{ident name}}: {{coalesce param_ts (tsType type)}}{{#unless @last}},{{/unless}}
    {{/each}}
  ): Promise<{{coalesce return_ts (retType .)}}> {
    return this.{{coalesce invoke (if (or (eq state_mutability "view") (eq state_mutability "pure")) "call" "transact")}}(
      {{json name}},
      [{{#each inputs}}{{ident name}}{{#unless @last}}, {{/unless}}{{/each}}]
    ) as Promise<{{coalesce return_ts (retType .)}}>;
  }

{{/each}}
  /** Expose event topic IDs (name → topic hex). */
  get eventTopics(): Readonly<Record<string, string>> { return TOPICS; }
}
