/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * TypeScript Codegen — Emit Contract Client Stubs
 * =================================================
 *
 * This generator turns a normalized ABI (see repo docs) into a typed
 * TypeScript client class that subclasses `ContractClient` from the TS SDK.
 *
 * Assumptions:
 * - Input ABI is already normalized (functions/events/errors carry
 *   `signature`, `selector`/`topic_id`, canonicalized types, and optional
 *   `discriminator` for overloads). If these are missing, we throw.
 *
 * Usage (programmatic):
 *   import { renderClient } from './gen';
 *   const code = renderClient(abiJson, { className: 'Counter' });
 *
 * CLI (node):
 *   ts-node sdk/codegen/typescript/gen.ts ./abi.json --class Counter
 */

type Optional<T> = T | undefined;

export interface TypeRef {
  kind: 'uint' | 'int' | 'bytes' | 'bool' | 'address' | 'string' | 'array' | 'tuple';
  bits?: number | null;
  array_item?: TypeRef | null;
  array_len?: number | null;
  tuple_elems?: TypeRef[] | null;
}

export interface ParamIR {
  name: string;
  type: TypeRef;
  indexed?: boolean;
}

export interface FunctionIR {
  name: string;
  inputs: ParamIR[];
  outputs: TypeRef[];
  state_mutability: 'pure' | 'view' | 'nonpayable' | 'payable';
  signature: string;   // e.g., "transfer(address,uint256)"
  selector: string;    // "0x..." sha3-256
  discriminator?: string | null;
}

export interface EventIR {
  name: string;
  inputs: ParamIR[];
  anonymous?: boolean;
  signature: string;
  topic_id: string;    // "0x..." sha3-256
  discriminator?: string | null;
}

export interface ErrorIR {
  name: string;
  inputs: ParamIR[];
  signature: string;
  selector: string;
  discriminator?: string | null;
}

export interface AbiIR {
  functions: FunctionIR[];
  events: EventIR[];
  errors?: ErrorIR[];
  metadata?: Record<string, any>;
}

export interface RenderOptions {
  className?: string;                        // default: ContractClientStub
  baseImport?: string;                       // default: @animica/sdk/contracts/client
  baseClass?: string;                        // default: ContractClient
  callMethod?: string;                       // default: call
  transactMethod?: string;                   // default: transact
  addressType?: string;                      // default: string (bech32m)
}

/** Render a TS module exporting a single strongly-typed client class. */
export function renderClient(
  abi: AbiIR | Record<string, any> | string,
  opts: RenderOptions = {},
): string {
  const {
    className = 'ContractClientStub',
    baseImport = '@animica/sdk/contracts/client',
    baseClass = 'ContractClient',
    callMethod = 'call',
    transactMethod = 'transact',
    addressType = 'string',
  } = opts;

  const ir = toIR(abi);
  validateIR(ir);

  const lines: string[] = [];
  const w = (s = '') => lines.push(s);

  // Header & imports
  w('/* This file was generated by Animica SDK codegen (TS). Do not edit. */');
  w(`import type { Abi } from '@animica/sdk/types/abi';`); // loose type; present in SDK
  w(`import { ${baseClass} } from '${baseImport}';`);
  w(`type Address = ${addressType};`);
  w('');

  // Embed ABI JSON (compact)
  const abiJson = JSON.stringify(irToPlain(ir));
  w(`export const ABI: Abi = JSON.parse(${jsString(abiJson)});`);
  w('');

  // Selectors & topics
  w('export const SELECTORS: Readonly<Record<string, string>> = {');
  ir.functions.forEach((fn, i) => {
    w(`  ${jsString(methodName(fn))}: ${jsString(fn.selector)}${comma(i, ir.functions.length)}`);
  });
  w('} as const;');
  w('');
  w('export const TOPICS: Readonly<Record<string, string>> = {');
  ir.events.forEach((ev, i) => {
    w(`  ${jsString(eventName(ev))}: ${jsString(ev.topic_id)}${comma(i, ir.events.length)}`);
  });
  w('} as const;');
  w('');

  // Class header / constructor
  w(`export class ${className} extends ${baseClass} {`);
  w(`  /** Create a client bound to \`address\`. */`);
  w(`  constructor(address: Address, opts: Partial<{ rpcUrl: string; chainId: number; signer: any; httpClient: any; }> = {}) {`);
  // Keep super signature consistent with our SDK base (`super(address, abi, opts)`)
  w(`    // @ts-ignore base class accepts (address, abi, opts)`);
  w(`    super(address, ABI, opts);`);
  w('  }');
  w('');

  // Methods
  ir.functions.forEach((fn) => {
    const sig = tsParamSignature(fn);
    const ret = tsReturnHint(fn);
    const doc = fnDoc(fn);
    const isView = fn.state_mutability === 'view' || fn.state_mutability === 'pure';
    const inv = isView ? callMethod : transactMethod;
    const argsArr = `[${argsForCall(fn)}]`;

    w(`  /** ${doc.split('\n').join('\n   * ')} */`);
    w(`  async ${methodName(fn)}(${sig}): Promise<${ret}> {`);
    w(`    return this.${inv}(${jsString(fn.name)}, ${argsArr}) as Promise<${ret}>;`);
    w('  }');
    w('');
  });

  // Event topics helper
  w('  /** Expose event topic IDs (name → topic hex). */');
  w('  get eventTopics(): Readonly<Record<string, string>> { return TOPICS; }');
  w('}');
  w('');

  return lines.join('\n');
}

// ------------------------------- helpers ----------------------------------

function toIR(abi: AbiIR | Record<string, any> | string): AbiIR {
  if (typeof abi === 'string') {
    return JSON.parse(abi) as AbiIR;
  }
  return abi as AbiIR;
}

function validateIR(ir: AbiIR): void {
  if (!ir || !Array.isArray(ir.functions) || !Array.isArray(ir.events)) {
    throw new Error('ABI IR must have `functions` and `events` arrays');
  }
  for (const fn of ir.functions) {
    if (!fn.signature || !fn.selector) {
      throw new Error(`Function ${fn.name} missing signature/selector (ensure ABI is normalized)`);
    }
  }
  for (const ev of ir.events) {
    if (!ev.signature || !ev.topic_id) {
      throw new Error(`Event ${ev.name} missing signature/topic_id (ensure ABI is normalized)`);
    }
  }
}

function irToPlain(ir: AbiIR): Record<string, any> {
  // Already plain, but ensure no undefined values to keep JSON compact.
  return JSON.parse(JSON.stringify(ir));
}

function jsString(s: string): string {
  // String literal safe for TS source
  return '`' + s.replace(/`/g, '\\`').replace(/\$\{/g, '\\${') + '`';
}

function comma(i: number, n: number): string {
  return i < n - 1 ? ',' : '';
}

function pyLikeCanonical(t: TypeRef): string {
  const k = t.kind;
  if (k === 'uint' || k === 'int') return `${k}${t.bits ?? ''}`;
  if (k === 'bytes') return t.bits ? `bytes${(t.bits / 8) | 0}` : 'bytes';
  if (k === 'bool' || k === 'address' || k === 'string') return k;
  if (k === 'array') {
    if (!t.array_item) throw new Error('array_item required');
    const inner = pyLikeCanonical(t.array_item);
    const suffix = t.array_len != null ? `[${t.array_len}]` : '[]';
    return `${inner}${suffix}`;
  }
  if (k === 'tuple') {
    const elems = (t.tuple_elems ?? []).map(pyLikeCanonical).join(',');
    return `(${elems})`;
  }
  return 'any';
}

function tsTypeHint(t: TypeRef): string {
  const k = t.kind;
  if (k === 'uint' || k === 'int') return 'bigint';
  if (k === 'bool') return 'boolean';
  if (k === 'bytes') return 'Uint8Array';
  if (k === 'string') return 'string';
  if (k === 'address') return 'string';
  if (k === 'array') {
    const inner = t.array_item ? tsTypeHint(t.array_item) : 'any';
    return `${inner}[]`;
  }
  if (k === 'tuple') {
    const elems = t.tuple_elems ?? [];
    if (elems.length === 0) return '[]';
    return `[${elems.map(tsTypeHint).join(', ')}]`;
  }
  return 'any';
}

function methodName(fn: FunctionIR): string {
  const base = tsIdent(fn.name);
  return fn.discriminator ? `${base}_${fn.discriminator}` : base;
}

function eventName(ev: EventIR): string {
  const base = tsIdent(ev.name);
  return ev.discriminator ? `${base}_${ev.discriminator}` : base;
}

function tsIdent(name: string): string {
  let s = (name || '').trim();
  if (!s) return '_unnamed';
  s = s
    .split('')
    .map((c) => (/[a-zA-Z0-9_]/.test(c) ? c : '_'))
    .join('');
  if (/^[0-9]/.test(s)) s = '_' + s;
  // Reserve TS/JS keywords
  const keywords = new Set([
    'break','case','catch','class','const','continue','debugger','default','delete','do','else','enum','export','extends',
    'false','finally','for','function','if','import','in','instanceof','new','null','return','super','switch','this',
    'throw','true','try','typeof','var','void','while','with','yield','let','static','implements','interface','package',
    'private','protected','public','await','as','from','of',
  ]);
  if (keywords.has(s)) s = s + '_';
  return s;
}

function tsParamSignature(fn: FunctionIR): string {
  return fn.inputs.map((p) => `${tsIdent(p.name)}: ${tsTypeHint(p.type)}`).join(', ');
}

function argsForCall(fn: FunctionIR): string {
  return fn.inputs.map((p) => tsIdent(p.name)).join(', ');
}

function tsReturnHint(fn: FunctionIR): string {
  const outs = fn.outputs ?? [];
  const isView = fn.state_mutability === 'view' || fn.state_mutability === 'pure';
  if (!isView) {
    // Mutating txs: SDK returns TxHash or Receipt; we leave as `any` to avoid tight coupling.
    return 'any';
  }
  if (outs.length === 0) return 'any';
  if (outs.length === 1) return tsTypeHint(outs[0]);
  return `[${outs.map(tsTypeHint).join(', ')}]`;
}

function fnDoc(fn: FunctionIR): string {
  const ins = fn.inputs.length
    ? fn.inputs.map((p) => `${p.name}:${pyLikeCanonical(p.type)}`).join(', ')
    : '—';
  const outs = fn.outputs.length ? fn.outputs.map(pyLikeCanonical).join(', ') : '—';
  return `${fn.name} ${fn.state_mutability}\nSignature: ${fn.signature}\nSelector: ${fn.selector}\nInputs: ${ins}\nReturns: ${outs}`;
}

// ------------------------------- CLI --------------------------------------

if (require.main === module) {
  // Simple CLI: ts-node gen.ts abi.json --class Name
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const fs = require('fs');
  const [, , abiPath, ...rest] = process.argv;
  if (!abiPath) {
    console.error('Usage: ts-node sdk/codegen/typescript/gen.ts <abi.json> [--class Name]');
    process.exit(1);
  }
  let className: Optional<string> = undefined;
  for (let i = 0; i < rest.length; i++) {
    if (rest[i] === '--class' && rest[i + 1]) {
      className = rest[i + 1];
      i++;
    }
  }
  const raw = fs.readFileSync(abiPath, 'utf8');
  const code = renderClient(JSON.parse(raw), { className: className ?? 'ContractClient' });
  process.stdout.write(code);
}
