# SDK Codegen — ABI ➜ Client Stubs (PY / TS / RS)

This document describes how a contract **ABI JSON** is normalized and turned into strongly-typed client stubs for **Python**, **TypeScript**, and **Rust**, using the shared codegen engines in `sdk/codegen/*`.

> Generated files are deterministic and reproducible. Every output begins with a banner:
>
> ```text
> // ⚠️ AUTO-GENERATED by animica codegen.
> // DO NOT EDIT BY HAND. See sdk/CODEGEN.md.
> ```

---

## 1) Inputs & Assumptions

- **ABI schema**: `sdk/common/schemas/abi.schema.json` (kept in sync with specs).
- **Encoding**: canonical length-prefixed ABI encoding used by the node & VM.
- **Supported types**: `int`, `bool`, `bytes`, `address`, fixed/array forms, tuples.
- **Events**: Named topics, canonical selector = `keccak256("Name(type1,type2,...)")`.
- **Errors**: Reverts are surfaced as structured errors with abi-coded payloads.

---

## 2) CLI Usage

### Python entry
```bash
python -m sdk.codegen.cli \
  --lang py \
  --abi sdk/common/examples/counter_abi.json \
  --out ./out_py

TypeScript entry (Node)

# Direct
node sdk/codegen/typescript/gen.ts --abi path/to/abi.json --out ./out_ts
# Or via the package helper (npx)
npx animica-codegen --abi path/to/abi.json --out ./out_ts

Rust entry

cargo run --manifest-path sdk/codegen/rust/Cargo.toml -- \
  --abi sdk/common/examples/counter_abi.json \
  --out ./out_rs

Common flags:
	•	--contract-name <Name> (override name inferred from ABI)
	•	--module <package/path> (language-specific module/crate path)
	•	--events on|off (emit event decoders)
	•	--overwrite (allow replacing existing files)

⸻

3) Normalization ➜ IR
	1.	Load & validate ABI against the JSON-Schema.
	2.	Normalize names (see §7), fold duplicate types, canonicalize tuples/arrays.
	3.	Build IR (sdk/codegen/common/model.py):
	•	Contract { name, functions[], events[], errors[] }
	•	Fn { name, inputs[], outputs[], stateMutability }
	•	Event { name, inputs[], indexed[] }
	•	Type { kind, of?, size?, components[] }

A stable fingerprint is computed over the normalized IR:

codegen_fingerprint = keccak256( canonical_json(IR) )

It is embedded into generated headers for provenance.

⸻

4) Language Targets & File Layouts

Python

Engine: sdk/codegen/python/gen.py, template: templates/contract_client.j2

Output (example):

<out_py>/
  counter_client.py       # class CounterClient
  counter_events.py       # decode_Inc(), event dataclasses
  __init__.py             # re-exports

Features:
	•	CounterClient(rpc, address, chain_id) with inc() / get() methods.
	•	Types: int (arbitrary precision), bytes (bytes), bool (bool), address (bech32m str validated by SDK).
	•	Return types as Python typing (e.g., tuple[int, bytes]).
	•	Event helpers: decode_event(log) -> Union[Inc, ...].

TypeScript

Engine: sdk/codegen/typescript/gen.ts, template: templates/contract_client.hbs

Output:

<out_ts>/index.ts                 # class CounterClient
<out_ts>/events.ts                # decodeInc(), typed payloads

Features:
	•	Methods are camelCase; numbers are bigint.
	•	Addresses are string (bech32m), validated by runtime helpers.
	•	Event decoders produce typed objects with args and raw.

Rust

Engine: sdk/codegen/rust/gen.rs, template: templates/contract_client.rs.hbs

Output:

<out_rs>/counter_client.rs        # struct CounterClient
<out_rs>/events.rs                # decode_inc(), event structs
mod.rs                            # pub use re-exports (optional)

Features:
	•	Methods are snake_case; integers map to num_bigint::BigUint (or U256 if your crate enables it).
	•	Addresses are String (bech32m); validators exposed in the SDK crate.
	•	Event decoders return typed structs; errors use thiserror.

⸻

5) Type Mapping

ABI Type	Python	TypeScript	Rust
int (unbounded)	int	bigint	BigUint (or U256 feature)
bool	bool	boolean	bool
bytes	bytes	Uint8Array	Vec<u8>
address (bech32m)	str	string	String
fixed array T[n]	tuple[T, ...]	T[] (length n)	Vec<T> (len checked)
dynamic array T[]	list[T]	T[]	Vec<T>
tuple (A,B,...)	tuple[A,B,...]	[A,B,...]	(<A,B,...>) or named struct

Encoders/decoders are injected from each language SDK (utils/cbor, utils/bytes, address).

⸻

6) Generated Method Signatures

Each function f(inputs) -> outputs generates:
	•	Python

async def f(self, *, args: FArgs, overrides: TxOverrides | None = None) -> FResult: ...

	•	overrides: fee, nonce, gas_limit, value (where applicable).
	•	For view/pure, codegen emits a call_f(...) convenience.

	•	TypeScript

f(args: FArgs, overrides?: TxOverrides): Promise<FResult>
callF(args: FArgs): Promise<FResult> // for view/pure


	•	Rust

pub async fn f(&self, args: FArgs, overrides: Option<TxOverrides>) -> Result<FResult, Error>;
pub async fn call_f(&self, args: FArgs) -> Result<FResult, Error>;



⸻

7) Naming Rules
	•	Contract class/struct: PascalCase of ABI name (fallback to file stem).
	•	Python methods/args: snake_case.
	•	TypeScript methods/args: camelCase.
	•	Rust methods/fields: snake_case.
	•	Tuple components with names become named fields where idiomatic (Rust struct).
	•	Name collisions are deconflicted with numeric suffixes (stable, deterministic).

⸻

8) Events

For each event:
	•	A selector topic0 = keccak256("Name(type1,type2,...)") is embedded.
	•	Generated helpers:
	•	Python: decode_event(log) -> EventUnion | None and per-event decode_<name>().
	•	TS: decodeEvent(log): DecodedEvent | null and decode<Name>().
	•	Rust: decode_event(log: &Log) -> Option<EventEnum> and per-event functions.

Indexed vs non-indexed parameters are handled per ABI; bytes/address normalization is consistent with node receipts.

⸻

9) Errors & Reverts

Reverts with ABI payloads generate typed error decoders:
	•	Python: AbiError subtypes with .data.
	•	TS: error objects { code, message, data } plus narrowable tags.
	•	Rust: Error::Revert(DecodedRevert) variants.

⸻

10) Determinism & Idempotence
	•	Output is byte-for-byte stable for the same inputs (ABI + codegen version).
	•	File order, import order, and member order are canonicalized.
	•	A codegen_fingerprint comment is emitted; changes to ABI or generator will alter it.

⸻

11) Templates & Engines
	•	Common IR & normalization: sdk/codegen/common/{normalize.py,model.py}
	•	Python: sdk/codegen/python/gen.py, templates/contract_client.j2
	•	TypeScript: sdk/codegen/typescript/gen.ts, templates/contract_client.hbs
	•	Rust: sdk/codegen/rust/gen.rs, templates/contract_client.rs.hbs

⸻

12) Testing
	•	Unit tests per language compile and call the Counter ABI:
	•	PY: sdk/python/tests/test_contract_codegen.py
	•	TS: sdk/typescript/test/contract_codegen.test.ts
	•	RS: sdk/rust/tests/contract_codegen.rs
	•	Cross-language vectors live under sdk/common/test_vectors/*.

⸻

13) Extending Codegen
	•	Add new ABI kinds in common/model.py and update type mappers per lang.
	•	Keep templates strictly logic-light; heavy transforms belong in the IR pass.
	•	Any new surface area must propagate to all three languages to keep parity.

⸻

14) Versioning

The generator embeds:
	•	codegen_version (from git describe).
	•	abi_hash (keccak of canonical ABI JSON).
	•	ir_hash (post-normalization).

These appear in the banner and can be surfaced at runtime for diagnostics.

⸻

15) FAQ

Q: Why bigint in TS and BigUint/U256 in Rust?
A: On-chain ints are potentially large; using big integer representations avoids silent overflows and keeps parity with Python’s arbitrary-precision int.

Q: Can I co-locate multiple contracts in one module?
A: Yes. Run codegen for each ABI to the same out directory; exports remain disjoint by class/struct names.

Q: How do I regenerate safely?
A: Re-run the CLI. It is idempotent; use --overwrite for intentional replacement.

