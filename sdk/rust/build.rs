// Build script for animica-sdk (Rust)
// Optionally bundles OpenRPC and ABI JSON schemas into the crate as string constants.
// Looks for files under ../common/schemas/{openrpc.json, abi.schema.json} relative to this crate.
// If not found, generates empty "{}" placeholders so the crate still compiles.

use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

fn find_schema(default_rel: &str, env_override: &str) -> Option<PathBuf> {
    if let Some(ov) = env::var_os(env_override) {
        let p = PathBuf::from(ov);
        if p.exists() {
            return Some(p);
        }
    }
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let p = manifest_dir.join(default_rel);
    if p.exists() {
        Some(p)
    } else {
        None
    }
}

fn read_or_warn(path: Option<PathBuf>, label: &str) -> (String, bool) {
    match path {
        Some(p) => {
            println!("cargo:rerun-if-changed={}", p.display());
            match fs::read_to_string(&p) {
                Ok(s) => (s, true),
                Err(e) => {
                    println!("cargo:warning=Failed to read {} at {}: {} (using \"{}\")", label, p.display(), e, "{}");
                    ("{}".to_string(), false)
                }
            }
        }
        None => {
            println!("cargo:warning=Could not locate {} (using \"{}\")", label, "{}");
            ("{}".to_string(), false)
        }
    }
}

// Escapes a Rust string literal safely using Debug formatter (produces quoted & escaped form).
fn rust_string_literal(s: &str) -> String {
    format!("{s:?}")
}

fn main() {
    // Allow environment overrides (absolute or relative paths)
    // ANIMICA_OPENRPC_JSON_PATH, ANIMICA_ABI_SCHEMA_JSON_PATH
    println!("cargo:rerun-if-env-changed=ANIMICA_OPENRPC_JSON_PATH");
    println!("cargo:rerun-if-env-changed=ANIMICA_ABI_SCHEMA_JSON_PATH");

    let openrpc_path = find_schema("../common/schemas/openrpc.json", "ANIMICA_OPENRPC_JSON_PATH");
    let abi_path = find_schema("../common/schemas/abi.schema.json", "ANIMICA_ABI_SCHEMA_JSON_PATH");

    let (openrpc_src, have_openrpc) = read_or_warn(openrpc_path, "OpenRPC schema (openrpc.json)");
    let (abi_src, have_abi) = read_or_warn(abi_path, "ABI schema (abi.schema.json)");

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let out_file = out_dir.join("schemas.rs");
    let mut f = fs::File::create(&out_file).expect("create OUT_DIR/schemas.rs");

    let have_all = have_openrpc && have_abi;

    // Generate a tiny module with string constants.
    // Consumers can: `mod schemas { include!(concat!(env!("OUT_DIR"), "/schemas.rs")); }`
    // and then use `schemas::OPENRPC_JSON` / `schemas::ABI_SCHEMA_JSON`.
    let content = format!(
        r#"
// @generated by build.rs â€” do not edit.
#[allow(dead_code)]
pub const HAS_BUNDLED_SCHEMAS: bool = {have_all};

#[allow(dead_code)]
pub const OPENRPC_JSON: &str = {openrpc};

#[allow(dead_code)]
pub const ABI_SCHEMA_JSON: &str = {abi};
"#,
        have_all = have_all,
        openrpc = rust_string_literal(&openrpc_src),
        abi = rust_string_literal(&abi_src),
    );

    f.write_all(content.as_bytes())
        .expect("write generated schemas.rs");
}
