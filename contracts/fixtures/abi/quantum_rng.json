{
  "abiVersion": 1,
  "name": "QuantumRng",
  "functions": [
    {
      "name": "owner",
      "stateMutability": "view",
      "inputs": [],
      "outputs": [
        {
          "type": {
            "abiType": "address"
          },
          "name": "addr"
        }
      ]
    },
    {
      "name": "params",
      "stateMutability": "view",
      "inputs": [],
      "outputs": [
        {
          "type": {
            "abiType": "u16"
          },
          "name": "minBits"
        },
        {
          "type": {
            "abiType": "u16"
          },
          "name": "maxBits"
        },
        {
          "type": {
            "abiType": "u16"
          },
          "name": "defaultShots"
        }
      ],
      "docs": "Current safety limits and default shot count for QRNG jobs."
    },
    {
      "name": "setParams",
      "stateMutability": "nonpayable",
      "inputs": [
        {
          "type": {
            "abiType": "u16"
          },
          "name": "minBits"
        },
        {
          "type": {
            "abiType": "u16"
          },
          "name": "maxBits"
        },
        {
          "type": {
            "abiType": "u16"
          },
          "name": "defaultShots"
        }
      ],
      "outputs": [
        {
          "type": {
            "abiType": "bool"
          },
          "name": "ok"
        }
      ],
      "docs": "Owner-only: set bounds and defaults for request()."
    },
    {
      "name": "lastTaskId",
      "stateMutability": "view",
      "inputs": [],
      "outputs": [
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "task_id"
        }
      ]
    },
    {
      "name": "lastEntropy",
      "stateMutability": "view",
      "inputs": [],
      "outputs": [
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "entropy"
        }
      ],
      "docs": "Entropy derived by the last successful mix(). Zero if none yet."
    },
    {
      "name": "lastBeacon",
      "stateMutability": "view",
      "inputs": [],
      "outputs": [
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "beacon"
        }
      ],
      "docs": "Beacon value that was used in the last successful mix()."
    },
    {
      "name": "request",
      "stateMutability": "nonpayable",
      "inputs": [
        {
          "type": {
            "abiType": "u16"
          },
          "name": "bits",
          "docs": "Requested number of random bits (bytes will be ceil(bits/8)). Must satisfy minBits <= bits <= maxBits."
        },
        {
          "type": {
            "abiType": "u16"
          },
          "name": "shots",
          "docs": "Quantum shots/samples; pass 0 to use defaultShots."
        },
        {
          "type": {
            "abiType": "bytes"
          },
          "name": "providerHint",
          "docs": "Optional provider/model hint (UTF-8). Pass b'' for default."
        }
      ],
      "outputs": [
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "task_id"
        }
      ],
      "docs": "Enqueue a QRNG job with the AICF. Returns deterministic task id."
    },
    {
      "name": "hasResult",
      "stateMutability": "view",
      "inputs": [
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "task_id"
        }
      ],
      "outputs": [
        {
          "type": {
            "abiType": "bool"
          },
          "name": "available"
        }
      ],
      "docs": "True if a QRNG result is available (typically next block)."
    },
    {
      "name": "readResult",
      "stateMutability": "view",
      "inputs": [
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "task_id"
        }
      ],
      "outputs": [
        {
          "type": {
            "abiType": "bool"
          },
          "name": "available"
        },
        {
          "type": {
            "abiType": "bytes"
          },
          "name": "raw",
          "docs": "Raw quantum bytes as returned by the provider (length >= ceil(bits/8))."
        }
      ],
      "docs": "Read the raw result without mutating contract state."
    },
    {
      "name": "mix",
      "stateMutability": "nonpayable",
      "inputs": [
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "task_id"
        }
      ],
      "outputs": [
        {
          "type": {
            "abiType": "bool"
          },
          "name": "ok"
        },
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "entropy"
        }
      ],
      "docs": "Derive entropy by mixing the current beacon with the QRNG bytes using extract-then-xor. Caches lastEntropy and emits Mixed(task_id, entropy). Reverts if result not yet available."
    },
    {
      "name": "expand",
      "stateMutability": "view",
      "inputs": [
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "seed",
          "docs": "If zero, uses lastEntropy; otherwise explicit seed."
        },
        {
          "type": {
            "abiType": "u32"
          },
          "name": "words"
        }
      ],
      "outputs": [
        {
          "type": {
            "abiType": "bytes"
          },
          "name": "out"
        }
      ],
      "docs": "Deterministic expansion via SHA3-256(seed||counter) to yield words*32 bytes."
    },
    {
      "name": "transferOwnership",
      "stateMutability": "nonpayable",
      "inputs": [
        {
          "type": {
            "abiType": "address"
          },
          "name": "newOwner"
        }
      ],
      "outputs": [
        {
          "type": {
            "abiType": "bool"
          },
          "name": "ok"
        }
      ]
    }
  ],
  "events": [
    {
      "name": "Enqueued",
      "inputs": [
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "task_id",
          "indexed": true
        },
        {
          "type": {
            "abiType": "u16"
          },
          "name": "bits",
          "indexed": false
        },
        {
          "type": {
            "abiType": "u16"
          },
          "name": "shots",
          "indexed": false
        }
      ]
    },
    {
      "name": "Mixed",
      "inputs": [
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "task_id",
          "indexed": true
        },
        {
          "type": {
            "abiType": "bytes32"
          },
          "name": "entropy",
          "indexed": false
        }
      ]
    },
    {
      "name": "ParamsUpdated",
      "inputs": [
        {
          "type": {
            "abiType": "u16"
          },
          "name": "minBits",
          "indexed": false
        },
        {
          "type": {
            "abiType": "u16"
          },
          "name": "maxBits",
          "indexed": false
        },
        {
          "type": {
            "abiType": "u16"
          },
          "name": "defaultShots",
          "indexed": false
        }
      ]
    },
    {
      "name": "OwnershipTransferred",
      "inputs": [
        {
          "type": {
            "abiType": "address"
          },
          "name": "previousOwner",
          "indexed": true
        },
        {
          "type": {
            "abiType": "address"
          },
          "name": "newOwner",
          "indexed": true
        }
      ]
    }
  ],
  "errors": [
    {
      "name": "NotOwner",
      "inputs": []
    },
    {
      "name": "BitsTooSmall",
      "inputs": []
    },
    {
      "name": "BitsTooLarge",
      "inputs": []
    },
    {
      "name": "InvalidShots",
      "inputs": []
    },
    {
      "name": "NoResultYet",
      "inputs": []
    }
  ],
  "docs": "Requests quantum-originated random bytes via AICF, then mixes the receipt with the randomness beacon using extract-then-xor to derive unbiased entropy. Caches last entropy for consumers."
}