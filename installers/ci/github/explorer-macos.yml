name: Explorer macOS — Tauri Build • Code Sign • Notarize • DMG

on:
  workflow_dispatch:
    inputs:
      channel:
        description: "Release channel"
        required: true
        default: "stable"
        type: choice
        options: [stable, beta]
      create_release:
        description: "Create GitHub Release"
        required: true
        default: "true"
        type: choice
        options: ["true","false"]
  push:
    tags:
      - "explorer-v*"

env:
  TAURI_PROJECT_PATH: installers/explorer-desktop/tauri
  ARTIFACTS_DIR: dist/macos
  RUST_TOOLCHAIN: stable
  # Build universal (arm64 + x64). Requires both targets present on the runner.
  TAURI_TARGETS: universal-apple-darwin

concurrency:
  group: explorer-macos-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  build-macos:
    name: Build & Notarize (macOS)
    runs-on: macos-14
    environment: release

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Derive version from tag or commit
        id: ver
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            VERSION="${TAG#explorer-v}"
          else
            VERSION="0.0.0-${GITHUB_SHA::7}"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Version: $VERSION"

      - name: Set up Rust (${{ env.RUST_TOOLCHAIN }})
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_TOOLCHAIN }}
          targets: aarch64-apple-darwin,x86_64-apple-darwin

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          cache-on-failure: true
          workspaces: ${{ env.TAURI_PROJECT_PATH }}

      - name: (Optional) Node setup for front-end (only if package.json exists)
        if: hashFiles(format('{0}/../package.json', env.TAURI_PROJECT_PATH)) != ''
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: ${{ env.TAURI_PROJECT_PATH }}/../package-lock.json

      - name: Install front-end deps (optional)
        if: hashFiles(format('{0}/../package.json', env.TAURI_PROJECT_PATH)) != ''
        working-directory: ${{ env.TAURI_PROJECT_PATH }}/..
        run: npm ci

      - name: Prepare output dir
        run: mkdir -p "$ARTIFACTS_DIR"

      # --------------------------------------------------------------------
      # Code signing certificate and keychain (p12 provided via secrets)
      # Secrets expected:
      #   MACOS_CERT_P12_BASE64  — base64-encoded .p12
      #   MACOS_CERT_PASSWORD    — password for .p12
      #   MACOS_SIGNING_IDENTITY — optional; e.g., "Developer ID Application: Animica (AB12C3D4E5)"
      # Notarization (either App-Specific Password or API Key):
      #   APPLE_ID + APPLE_APP_PASSWORD
      #     OR
      #   APPLE_API_KEY_ID + APPLE_API_ISSUER + APPLE_API_KEY_P8 (base64)
      # --------------------------------------------------------------------
      - name: Create ephemeral keychain & import cert
        env:
          CERT_P12_B64: ${{ secrets.MACOS_CERT_P12_BASE64 }}
          CERT_PASSWORD: ${{ secrets.MACOS_CERT_PASSWORD }}
        run: |
          set -euo pipefail
          KEYCHAIN="build.keychain-db"
          KEYCHAIN_PW="$(openssl rand -base64 24)"
          security create-keychain -p "$KEYCHAIN_PW" "$KEYCHAIN"
          security set-keychain-settings -lut 21600 "$KEYCHAIN"
          security unlock-keychain -p "$KEYCHAIN_PW" "$KEYCHAIN"
          echo "$KEYCHAIN_PW" > $RUNNER_TEMP/keychain_pw.txt
          # Import certificate
          echo "$CERT_P12_B64" | base64 --decode > $RUNNER_TEMP/cert.p12
          security import $RUNNER_TEMP/cert.p12 -k "$KEYCHAIN" -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
          # Allow codesign to use the key non-interactively
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PW" "$KEYCHAIN"
          # Make our keychain the only one in search list (highest priority)
          security list-keychains -d user -s "$KEYCHAIN" login.keychain-db
          security default-keychain -s "$KEYCHAIN"
          rm -f $RUNNER_TEMP/cert.p12

      - name: Build with tauri-action (universal)
        id: tauri
        uses: tauri-apps/tauri-action@v0
        env:
          # Tauri version overrides (picked up by bundler and Info.plist)
          TAURI_APP_VERSION: ${{ steps.ver.outputs.version }}
          TAURI_BUILD_VERSION: ${{ steps.ver.outputs.version }}
          # Optional identity override (else auto-detected from keychain)
          APPLE_SIGNING_IDENTITY: ${{ secrets.MACOS_SIGNING_IDENTITY }}
          # Notarization via API key (preferred)
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY_P8 }}
          # Or via Apple ID + app-specific password (fallback)
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.MACOS_TEAM_ID }}
        with:
          projectPath: ${{ env.TAURI_PROJECT_PATH }}
          args: --verbose
          target: ${{ env.TAURI_TARGETS }}
          tagName: explorer-v__VERSION__           # replaced automatically by the action
          releaseName: "Explorer macOS v__VERSION__"
          releaseBody: "Universal DMG notarized and signed."
          releaseDraft: false
          prerelease: ${{ (github.event_name == 'workflow_dispatch' && inputs.channel == 'beta') || (startsWith(github.ref, 'refs/tags/') && contains(github.ref_name, '-beta')) }}

      - name: Collect artifacts -> ${{ env.ARTIFACTS_DIR }}
        run: |
          echo "Paths from tauri-action:"
          echo '${{ steps.tauri.outputs.artifactPaths }}'
          paths=$(python3 - <<'PY'
import json, os, sys
arr=json.loads(os.environ['ARTS'])
for p in arr:
  if os.path.exists(p):
    print(p)
PY
          )
          mkdir -p "$ARTIFACTS_DIR"
          while IFS= read -r p; do
            echo "Copy: $p"
            cp -v "$p" "$ARTIFACTS_DIR"/
          done <<< "$paths"
        env:
          ARTS: ${{ steps.tauri.outputs.artifactPaths }}

      - name: Verify signatures & staple (DMG/APP)
        run: |
          set -e
          ls -lah "$ARTIFACTS_DIR"
          # Verify code signatures
          for f in "$ARTIFACTS_DIR"/*; do
            if [[ "$f" == *.dmg || "$f" == *.app || "$f" == *.zip ]]; then
              echo "::group::codesign verification for $f"
              codesign --verify --deep --strict --verbose=2 "$f" || exit 1
              echo "::endgroup::"
            fi
          done
          # Staple (no-op if already stapled by tauri-action)
          for f in "$ARTIFACTS_DIR"/*.dmg "$ARTIFACTS_DIR"/*.app 2>/dev/null; do
            [ -e "$f" ] || continue
            xcrun stapler staple "$f" || true
          done

      - name: Checksums
        run: |
          (cd "$ARTIFACTS_DIR" && shasum -a 256 * > SHA256SUMS.txt && shasum -a 512 * > SHA512SUMS.txt || true)
          ls -lah "$ARTIFACTS_DIR"

      - name: Upload workflow artifacts
        uses: actions/upload-artifact@v4
        with:
          name: explorer-macos-${{ steps.ver.outputs.version }}
          path: |
            ${{ env.ARTIFACTS_DIR }}/*.dmg
            ${{ env.ARTIFACTS_DIR }}/*.app
            ${{ env.ARTIFACTS_DIR }}/*.zip
            ${{ env.ARTIFACTS_DIR }}/SHA256SUMS.txt
            ${{ env.ARTIFACTS_DIR }}/SHA512SUMS.txt

      - name: Create GitHub Release (optional)
        if: ${{ (github.event_name == 'workflow_dispatch' && inputs.create_release == 'true') || startsWith(github.ref, 'refs/tags/') }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name || format('explorer-v{0}', steps.ver.outputs.version) }}
          name: "Explorer macOS v${{ steps.ver.outputs.version }}"
          draft: false
          prerelease: ${{ inputs.channel == 'beta' }}
          files: |
            ${{ env.ARTIFACTS_DIR }}/*.dmg
            ${{ env.ARTIFACTS_DIR }}/*.app
            ${{ env.ARTIFACTS_DIR }}/*.zip
            ${{ env.ARTIFACTS_DIR }}/SHA256SUMS.txt
            ${{ env.ARTIFACTS_DIR }}/SHA512SUMS.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup keychain
        if: always()
        run: |
          KEYCHAIN="build.keychain-db"
          if security list-keychains | grep -q "$KEYCHAIN"; then
            security delete-keychain "$KEYCHAIN" || true
          fi
