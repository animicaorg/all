#!/usr/bin/env node
/**
 * make_sprite.mjs — packs contrib/icons/system/*.svg into a single SVG sprite.
 *
 * Usage:
 *   node contrib/icons/scripts/make_sprite.mjs
 *
 * Output:
 *   contrib/icons/sprite/sprite.svg
 *
 * Notes:
 * - No dependencies required. If "svgo" is installed, we'll optionally optimize.
 * - Symbols use the filename (without .svg) as the <symbol id="...">.
 * - Preserves each source SVG's viewBox; falls back to 0 0 24 24 if missing.
 */

import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';

// Resolve repo-relative paths from this script location
const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

const SYSTEM_DIR = path.resolve(__dirname, '../system');
const OUT_DIR    = path.resolve(__dirname, '../sprite');
const OUT_FILE   = path.resolve(OUT_DIR, 'sprite.svg');

// Try to load SVGO if available (optional)
let svgoOptimize = null;
try {
  const svgoMod = await import('svgo').catch(() => null);
  if (svgoMod?.optimize) svgoOptimize = svgoMod.optimize;
} catch (_) {
  svgoOptimize = null;
}

function toTitle(id) {
  // "arrow-right" → "Arrow Right"
  return id
    .replace(/\.[^/.]+$/, '')
    .split(/[-_]+/)
    .filter(Boolean)
    .map(s => s[0]?.toUpperCase() + s.slice(1))
    .join(' ');
}

function extractViewBox(svg) {
  const vb = svg.match(/viewBox\s*=\s*"([^"]+)"/i)?.[1]
          || svg.match(/viewBox\s*=\s*'([^']+)'/i)?.[1];
  if (vb) return vb;

  // Fallback from width/height if present
  const w = svg.match(/\bwidth\s*=\s*"?(\d+(?:\.\d+)?)"?/i)?.[1];
  const h = svg.match(/\bheight\s*=\s*"?(\d+(?:\.\d+)?)"?/i)?.[1];
  if (w && h) return `0 0 ${w} ${h}`;
  return '0 0 24 24';
}

function stripOuter(svg) {
  // remove xml declaration and comments
  let s = svg
    .replace(/<\?xml[^>]*>/g, '')
    .replace(/<!--[\s\S]*?-->/g, '');

  // strip <title> and <desc> inside inner content (we add aria-label on symbol)
  s = s.replace(/<title[^>]*>[\s\S]*?<\/title>/gi, '')
       .replace(/<desc[^>]*>[\s\S]*?<\/desc>/gi, '');

  // extract inner between <svg ...> and </svg>
  const m = s.match(/<svg[^>]*>([\s\S]*?)<\/svg>/i);
  return (m ? m[1] : s).trim();
}

async function readIcons(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  return entries
    .filter(e => e.isFile() && e.name.toLowerCase().endsWith('.svg'))
    .map(e => path.join(dir, e.name))
    .sort((a, b) => a.localeCompare(b));
}

async function maybeOptimize(svg, pathHint) {
  if (!svgoOptimize) return svg;
  try {
    const { data } = svgoOptimize(svg, {
      path: pathHint,
      multipass: true,
      plugins: [
        { name: 'preset-default', params: { overrides: { removeViewBox: false, cleanupIds: false } } },
        { name: 'removeDimensions' },
        { name: 'sortAttrs' },
        { name: 'convertStyleToAttrs' },
        { name: 'convertColor', params: { currentColor: true } },
      ],
    });
    return data;
  } catch {
    return svg;
  }
}

async function buildSprite() {
  await fs.mkdir(OUT_DIR, { recursive: true });

  const files = await readIcons(SYSTEM_DIR);
  if (files.length === 0) {
    console.warn('[make_sprite] No SVGs found in', SYSTEM_DIR);
  }

  const symbols = [];
  for (const f of files) {
    const raw = await fs.readFile(f, 'utf8');
    const optimized = await maybeOptimize(raw, f);

    const id = path.basename(f, '.svg');
    const viewBox = extractViewBox(optimized);
    const inner = stripOuter(optimized);

    const label = toTitle(id);
    const symbol =
`  <symbol id="${id}" viewBox="${viewBox}" role="img" aria-label="${label}">
${inner.split('\n').map(l => '    ' + l).join('\n')}
  </symbol>`;

    symbols.push(symbol);
  }

  const sprite =
`<!-- Generated by make_sprite.mjs. Do not edit by hand. -->
<svg xmlns="http://www.w3.org/2000/svg" style="display:none">
${symbols.join('\n\n')}
</svg>
`;

  await fs.writeFile(OUT_FILE, sprite, 'utf8');

  // Also emit a manifest for convenience
  const manifestPath = path.resolve(OUT_DIR, 'manifest.json');
  const manifest = {
    generatedAt: new Date().toISOString(),
    source: pathToFileURL(SYSTEM_DIR).toString(),
    count: symbols.length,
    symbols: files.map(f => path.basename(f, '.svg')),
  };
  await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2) + '\n', 'utf8');

  console.log(`[make_sprite] Packed ${symbols.length} icon(s) → ${path.relative(process.cwd(), OUT_FILE)}`);
}

buildSprite().catch(err => {
  console.error('[make_sprite] Failed:', err?.stack || err);
  process.exit(1);
});
