# Circuits & Artifacts — Build & Reproducibility

This directory documents how zero-knowledge circuit artifacts are compiled, versioned, and verified for reproducibility. It is **process-centric** (how to build + attest) rather than **circuit-centric** (what a specific circuit proves). See `zk/ROADMAP.md` for planned circuits.

> TL;DR: We compile with *pinned toolchain versions* inside a *pinned container*, record *content hashes* for inputs/outputs in a canonical `artifacts-manifest.json`, and compute a single **Reproducibility Hash** over that manifest. Anyone can re-run the pipeline and recompute the same hash.

---

## Directory Layout

zk/
circuits/
README.md                    ← this file
Makefile                     ← convenience targets (see zk/Makefile root too)
toolchain.lock.json          ← resolved versions (circom, snarkjs, node, npm)
powertau/                    ← (optional) checked-in pointers + hashes to ptau files
README.md
registry.json              ← name → URL(s) + SHA256/BLAKE3
<circuit_name>/
circuit.circom
config.json                ← (optional) circom/snarkjs flags
input.example.json         ← tiny vector for smoke proof
artifacts/
<circuit_name>.r1cs
<circuit_name>.wasm
<circuit_name>.zkey
verification_key.json
witness_calculator.js    ← generated by circom (if applicable)
BLAKE3SUMS               ← per-file blake3
SHA256SUMS               ← per-file sha256
artifacts-manifest.json  ← canonical manifest (see schema below)
REPRODUCIBILITY_HASH     ← single-line hex (blake3 of canonical manifest)

Artifacts (`.r1cs`, `.wasm`, `.zkey`, `verification_key.json`) are **not** committed to git in general (see `.gitignore`). Instead, we keep:
- Small example inputs and configs.
- Content-addressed references (hashes/URLs) to **ptau** and release bundles.
- A **manifest schema** to attest reproducible builds.

---

## Tooling & Versions

We pin the entire toolchain so the same sources produce byte-for-byte identical outputs:

- **circom**: pinned (e.g., `2.1.7`)  
- **snarkjs**: pinned (e.g., `0.7.4`)  
- **node**/**npm**: pinned (via `toolchain.lock.json`)  
- **Docker** image digest for hermetic builds (recommended)  
- **Powers of Tau**: exact file + cryptographic hash (SHA256 + BLAKE3)

> Use the container for deterministic builds:
>
> ```bash
> # Example: iden3/circom pinned by digest (replace with actual digest in toolchain.lock)
> docker pull iden3/circom:2.1.7@sha256:<digest>
> ```

---

## Standard Build Pipeline (Groth16)

Below is the reference pipeline; PLONK/KZG is similar (see variant notes further down).

1. **Prepare environment**
   ```bash
   cd zk/circuits/<circuit_name>
   # Optional: use our pinned container
   # docker run --rm -it -v "$PWD:/work" -w /work iden3/circom:2.1.7@sha256:<digest> bash

	2.	Compile circom → R1CS/WASM/SYM

circom circuit.circom \
  --r1cs --wasm --sym \
  --output artifacts \
  --O2


	3.	Fetch Powers of Tau (ptau)
	•	Choose a ptau file with size ≥ constraints of your circuit (see powertau/registry.json).
	•	Verify its hash before use:

# Example: verify local ptau file against registry
sha256sum artifacts/pot28_final.ptau
b3sum    artifacts/pot28_final.ptau


	4.	Groth16 setup

# Initial zkey
snarkjs groth16 setup artifacts/<circuit_name>.r1cs artifacts/pot28_final.ptau artifacts/<circuit_name>.zkey

Reproducibility note: Contributions (zkey contribute) introduce entropy → non-determinism. For fully reproducible builds we either:
	•	Use a deterministic beacon to finalize the zkey:

snarkjs zkey beacon artifacts/<circuit_name>.zkey \
  artifacts/<circuit_name>.zkey \
  "<HEX_BEACON_STRING>" 10

(Choose a published <HEX_BEACON_STRING> and iteration count; record both in the manifest.)

	•	Or publish a canonical zkey (content-addressed) and treat it as an input to reproducibility (i.e., build = verify integrity rather than re-derive randomness).

	5.	Export verification key

snarkjs zkey export verificationkey \
  artifacts/<circuit_name>.zkey \
  artifacts/verification_key.json


	6.	(Optional) Smoke-proof with example input

# witness
node artifacts/<circuit_name>_js/generate_witness.js \
     artifacts/<circuit_name>.wasm input.example.json artifacts/witness.wtns

# proof
snarkjs groth16 prove artifacts/<circuit_name>.zkey artifacts/witness.wtns artifacts/proof.json artifacts/public.json

# verify
snarkjs groth16 verify artifacts/verification_key.json artifacts/public.json artifacts/proof.json



⸻

Reproducibility Manifests & Hash

We compute per-file hashes and a canonical Reproducibility Hash:
	1.	Per-file hashes

(cd artifacts && \
  b3sum --no-names ./* > BLAKE3SUMS && \
  sha256sum ./* > SHA256SUMS)


	2.	Canonical artifacts-manifest.json
Minimal schema (JSON with sorted keys when serialized):

{
  "schema": "animica.zk.artifacts.v1",
  "circuit": {
    "name": "<circuit_name>",
    "source_path": "circuit.circom",
    "git_rev": "<git_commit_sha>",
    "git_dirty": false
  },
  "toolchain": {
    "circom": "2.1.7",
    "snarkjs": "0.7.4",
    "node": "18.19.0",
    "docker_image": "iden3/circom:2.1.7@sha256:<digest>"
  },
  "ptau": {
    "name": "powersOfTau28_hez_final_20.ptau",
    "sha256": "<hex>",
    "blake3": "<hex>",
    "source": "https://example/ptau/pot28_hez_final_20.ptau"
  },
  "build": {
    "timestamp_utc": "2025-01-01T00:00:00Z",
    "commands": [
      "circom circuit.circom --r1cs --wasm --sym --output artifacts --O2",
      "snarkjs groth16 setup artifacts/<circuit>.r1cs artifacts/<ptau> artifacts/<circuit>.zkey",
      "snarkjs zkey beacon artifacts/<circuit>.zkey artifacts/<circuit>.zkey <beacon> 10",
      "snarkjs zkey export verificationkey artifacts/<circuit>.zkey artifacts/verification_key.json"
    ],
    "beacon": {
      "hex": "<HEX_BEACON_STRING>",
      "iterations": 10
    }
  },
  "outputs": {
    "r1cs": { "path": "artifacts/<circuit>.r1cs", "size": 0, "sha256": "<hex>", "blake3": "<hex>" },
    "wasm": { "path": "artifacts/<circuit>.wasm", "size": 0, "sha256": "<hex>", "blake3": "<hex>" },
    "zkey": { "path": "artifacts/<circuit>.zkey", "size": 0, "sha256": "<hex>", "blake3": "<hex>" },
    "vk":   { "path": "artifacts/verification_key.json", "size": 0, "sha256": "<hex>", "blake3": "<hex>" }
  }
}


	3.	Compute the single Reproducibility Hash
Use canonical JSON serialization (sorted keys, no insignificant whitespace), then BLAKE3:

# requires jq ≥1.6
jq -S . artifacts/artifacts-manifest.json | tr -d '\n' > /tmp/manifest.canonical.json
b3sum /tmp/manifest.canonical.json | awk '{print $1}' > artifacts/REPRODUCIBILITY_HASH
cat artifacts/REPRODUCIBILITY_HASH

The content of REPRODUCIBILITY_HASH is the attestation for this artifact set. Anyone who re-runs the pipeline with identical inputs should get the same value.

Important: If you rely on a prebuilt zkey (e.g., from a multi-party ceremony), include its hash in ptau or an additional zkey_inputs section and treat it as an input to reproducibility. The overall reproducibility then validates integrity of that dependency rather than regenerating it.

⸻

Variant: PLONK (KZG)

For PLONK:

snarkjs plonk setup artifacts/<circuit>.r1cs artifacts/<ptau> artifacts/<circuit>.zkey
snarkjs zkey export verificationkey artifacts/<circuit>.zkey artifacts/verification_key.json

Update the manifest "scheme": "plonk" and record the same hashes + versions. PLONK has a single-phase setup; reproducibility concerns mirror Groth16 (ptau integrity + deterministic zkey derivation if applicable).

⸻

Make Targets (Convenience)

From repo root (delegates to zk/Makefile):

# Compile + setup + vk export + manifest + hash for one circuit
make -C zk <circuit_name>/build

# Refresh verification key only (given existing zkey)
make -C zk <circuit_name>/vk-refresh

# Verify hashes against manifest
make -C zk <circuit_name>/verify

# Clean artifacts
make -C zk <circuit_name>/clean

Each target writes/updates artifacts-manifest.json, BLAKE3SUMS, SHA256SUMS, and REPRODUCIBILITY_HASH.

⸻

Publishing & Verification
	•	Publish artifacts/ as a tarball with:
	•	artifacts-manifest.json
	•	REPRODUCIBILITY_HASH
	•	Per-file sums
	•	The artifacts themselves
	•	Sign the tarball (or the manifest) with your preferred tool:

minisign -S -m artifacts/artifacts-manifest.json -s /path/to/minisign.key
# or cosign attach attestation/signature to the release artifact


	•	Verify on download:

jq -S . artifacts-manifest.json | tr -d '\n' | b3sum -c <(sed 's/$/  -/' REPRODUCIBILITY_HASH)
sha256sum -c SHA256SUMS
b3sum    -c BLAKE3SUMS
snarkjs groth16 verify verification_key.json public.json proof.json



⸻

Practical Tips & Pitfalls
	•	Line endings: Ensure LF (not CRLF) for reproducible wasm/js outputs; use .gitattributes if necessary.
	•	Circom flags: Optimization levels (--O0/--O1/--O2) can change R1CS; pin them in config.json and the manifest.
	•	Node/npm: Different Node versions can alter node_modules transitive tree → use the container or lockfiles.
	•	Witness determinism: Witnesses depend on inputs; they are not part of artifact reproducibility but are great for smoke tests.
	•	Large files: Prefer publishing via release assets / object storage with hashes instead of committing to git.

⸻

Minimal End-to-End Example

# Example with "demo" circuit:
cd zk/circuits/demo

# 1) compile
circom circuit.circom --r1cs --wasm --sym --output artifacts --O2

# 2) verify ptau hash, then setup (Groth16)
snarkjs groth16 setup artifacts/demo.r1cs artifacts/pot28_final.ptau artifacts/demo.zkey

# 3) deterministic beacon finalize (replace with published beacon from docs)
snarkjs zkey beacon artifacts/demo.zkey artifacts/demo.zkey 0123456789abcdef 10

# 4) verification key
snarkjs zkey export verificationkey artifacts/demo.zkey artifacts/verification_key.json

# 5) hashes + manifest + reproducibility hash
b3sum --no-names artifacts/* > artifacts/BLAKE3SUMS
sha256sum artifacts/* > artifacts/SHA256SUMS
# write artifacts-manifest.json (use script/Makefile), then:
jq -S . artifacts/artifacts-manifest.json | tr -d '\n' | b3sum | awk '{print $1}' > artifacts/REPRODUCIBILITY_HASH

If your recomputed REPRODUCIBILITY_HASH matches the published one, the build is reproducible under the specified inputs and toolchain.

⸻

FAQ

Q: Why BLAKE3 and SHA256?
A: BLAKE3 is very fast for local workflows; SHA256 is ubiquitous for cross-ecosystem verification. We record both.

Q: Can we avoid trusted setup?
A: For Groth16/PLONK you need some form of setup (ptau or CRS). You can use a widely-audited ceremony and treat its output as an input with attested hash. STARKs avoid trusted setup but have different tradeoffs.

Q: What breaks reproducibility most often?
A: Unpinned toolchain versions, unrecorded beacons/contributions, and environment drift (Node/OS). Use the pinned container.

⸻

Last updated: keep pinned versions in toolchain.lock.json and bump deliberately with a note in zk/ROADMAP.md.
