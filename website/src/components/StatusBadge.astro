---
import { rpcUrl as defaultRpcUrl } from "../env";

type RpcHealth = "healthy" | "degraded" | "offline";

type Thresholds = {
  healthyLatencyMs: number;
  degradeLatencyMs: number;
  offlineConsecutiveFails: number;
  staleMs: number;
};

type Props = {
  rpcUrl?: string;
  intervalMs?: number;
  timeoutMs?: number;
  thresholds?: Partial<Thresholds>;
  showLatency?: boolean;
  className?: string;
  size?: "sm" | "md" | "lg";
};

const DEFAULT_THRESHOLDS: Thresholds = {
  healthyLatencyMs: 300,
  degradeLatencyMs: 1000,
  offlineConsecutiveFails: 3,
  staleMs: 20_000,
};

const {
  rpcUrl = defaultRpcUrl || "/rpc",
  intervalMs = 4000,
  timeoutMs = 2500,
  thresholds = {},
  showLatency = true,
  className = "",
  size = "md",
} = Astro.props as Props;

const mergedThresholds = { ...DEFAULT_THRESHOLDS, ...(thresholds || {}) };
const sizeCls =
  size === "sm"
    ? "text-xs px-2 py-1 gap-2"
    : size === "lg"
    ? "text-sm px-3 py-2 gap-3"
    : "text-sm px-2.5 py-1.5 gap-2";
const dotSize = size === "sm" ? "size-2" : size === "lg" ? "size-2.5" : "size-2";
const uid = `status-badge-${Math.random().toString(36).slice(2, 9)}`;

const statusStyles: Record<RpcHealth, { ring: string; dot: string; label: string }> = {
  healthy: { ring: "ring-emerald-500/25", dot: "bg-emerald-500", label: "Healthy" },
  degraded: { ring: "ring-amber-500/25", dot: "bg-amber-500", label: "Degraded" },
  offline: { ring: "ring-rose-500/25", dot: "bg-rose-500", label: "Offline" },
};

const config = JSON.stringify({
  url: rpcUrl,
  intervalMs,
  timeoutMs,
  thresholds: mergedThresholds,
  showLatency,
});
---
<div
  id={uid}
  class={`inline-flex items-center rounded-full border bg-[var(--bg-elevated)]
    border-[color-mix(in_srgb,var(--text-primary)_/_12%,transparent)] ring-4 ${statusStyles.offline.ring}
    ${sizeCls} ${className}`}
  data-config={config}
  aria-live="polite"
  role="status"
>
  <span
    class={`inline-block rounded-full ${dotSize} ${statusStyles.offline.dot}`}
    data-role="dot"
    aria-hidden="true"
  />
  <span class="font-medium" data-role="label">{statusStyles.offline.label}</span>
  {showLatency && <span class="ml-1 tabular-nums opacity-75" data-role="latency">—</span>}
</div>
<script>
(() => {
  const DEFAULT_THRESHOLDS = {
    healthyLatencyMs: 300,
    degradeLatencyMs: 1000,
    offlineConsecutiveFails: 3,
    staleMs: 20000,
  };
  const statusStyles = {
    healthy: { ring: "ring-emerald-500/25", dot: "bg-emerald-500", label: "Healthy" },
    degraded: { ring: "ring-amber-500/25", dot: "bg-amber-500", label: "Degraded" },
    offline: { ring: "ring-rose-500/25", dot: "bg-rose-500", label: "Offline" },
  };

  const root = document.getElementById("${uid}");
  if (!root) return;

  const cfg = (() => {
    try {
      return JSON.parse(root.dataset.config || "{}");
    } catch {
      return {};
    }
  })();

  const url = cfg.url || "/rpc";
  const intervalMs = Number(cfg.intervalMs) || 4000;
  const timeoutMs = Number(cfg.timeoutMs) || 2500;
  const thresholds = Object.assign({}, DEFAULT_THRESHOLDS, cfg.thresholds || {});
  const showLatency = Boolean(cfg.showLatency);

  const dotEl = root.querySelector('[data-role="dot"]');
  const labelEl = root.querySelector('[data-role="label"]');
  const latencyEl = root.querySelector('[data-role="latency"]');

  let status = "offline";
  let latencyMs = null;
  let lastOkAt = null;
  let head = null;
  let errMsg = null;
  let failStreak = 0;
  let timer = null;

  function deriveStatus() {
    const now = Date.now();
    const stale = lastOkAt != null ? now - lastOkAt > thresholds.staleMs : true;
    if (failStreak >= thresholds.offlineConsecutiveFails || stale) return "offline";
    if (latencyMs == null) return "degraded";
    if (latencyMs <= thresholds.healthyLatencyMs) return "healthy";
    if (latencyMs <= thresholds.degradeLatencyMs) return "degraded";
    return "degraded";
  }

  function updateVisuals(nextStatus) {
    const styles = statusStyles[nextStatus];
    root.classList.remove(statusStyles.healthy.ring, statusStyles.degraded.ring, statusStyles.offline.ring);
    root.classList.add(styles.ring);
    if (dotEl) {
      dotEl.classList.remove(statusStyles.healthy.dot, statusStyles.degraded.dot, statusStyles.offline.dot);
      dotEl.classList.add(styles.dot);
    }
    if (labelEl) labelEl.textContent = styles.label;
    if (latencyEl && showLatency) {
      latencyEl.textContent = latencyMs != null ? `${Math.round(latencyMs)} ms` : "—";
    }
  }

  function updateTooltip() {
    const tooltip = [
      showLatency && latencyMs != null ? `RTT: ${latencyMs.toFixed(0)} ms` : "",
      head != null ? `Head: ${head}` : "",
      lastOkAt ? `Last OK: ${new Date(lastOkAt).toLocaleTimeString()}` : "",
      errMsg ? `Last error: ${errMsg}` : "",
    ]
      .filter(Boolean)
      .join("\n");
    if (tooltip) root.setAttribute("title", tooltip);
  }

  async function rpcCall(method, params) {
    const id = Math.floor(Math.random() * 1e9);
    const ctrl = new AbortController();
    const to = window.setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ jsonrpc: "2.0", id, method, params }),
        signal: ctrl.signal,
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const body = await res.json();
      if (body?.error) throw new Error(body.error.message || "RPC error");
      return { ok: true, result: body.result };
    } catch (err) {
      return { ok: false, error: err instanceof Error ? err : new Error(String(err)) };
    } finally {
      clearTimeout(to);
    }
  }

  async function ping() {
    const t0 = performance.now();
    const res = await rpcCall("chain.getHead");
    const t1 = performance.now();
    if (res.ok) {
      const rtt = Math.max(0, t1 - t0);
      latencyMs = rtt;
      lastOkAt = Date.now();
      head = res.result?.number ?? null;
      errMsg = null;
      failStreak = 0;
    } else {
      errMsg = res.error?.message || "RPC error";
      failStreak += 1;
    }

    const nextStatus = deriveStatus();
    if (nextStatus !== status) {
      status = nextStatus;
      updateVisuals(status);
    } else if (showLatency && latencyEl) {
      latencyEl.textContent = latencyMs != null ? `${Math.round(latencyMs)} ms` : "—";
    }
    updateTooltip();
  }

  ping();
  timer = window.setInterval(ping, intervalMs);
  window.addEventListener("pagehide", () => timer && clearInterval(timer), { once: true });
})();
</script>
