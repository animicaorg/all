import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "node:path";

/**
 * Vite config for an MV3 browser extension.
 *
 * We build three HTML pages (popup / onboarding / approve) *and*
 * two JS entrypoints (background service worker + content scripts).
 *
 * The HTML files live under public/ and each one bootstraps its TSX entry via a <script type="module"> tag.
 * The background & content scripts are added as extra Rollup inputs so they’re emitted as standalone chunks
 * that the manifest will reference (generated by scripts/build.ts).
 */
export default defineConfig(({ mode }) => ({
  plugins: [react()],
  publicDir: "public",
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "src"),
      "@noble/hashes": path.resolve(__dirname, "src/polyfills/noble"),
    }
  },
  define: {
    __DEV__: mode !== "production"
  },
  build: {
    outDir: "dist",
    emptyOutDir: false, // scripts/build.ts may pre-copy assets / manifests
    sourcemap: mode !== "production" ? true : false,
    target: "es2022",
    // The background service worker runs in a worker-like global without
    // DOM APIs such as `window`/`document`. Vite's modulepreload helpers
    // inject DOM touchpoints into every entry chunk, which causes runtime
    // failures when the background loads (ReferenceError: window is not defined).
    // Chrome/Firefox MV3 already support modulepreload, so disable Vite's
    // injection entirely to keep the background bundle worker-safe.
    modulePreload: false,
    rollupOptions: {
      input: {
        // UI pages (HTML multi-page build)
        popup: path.resolve(__dirname, "public/popup.html"),
        onboarding: path.resolve(__dirname, "public/onboarding.html"),
        approve: path.resolve(__dirname, "public/approve.html"),

        // Non-HTML entries (built as chunks for MV3 manifest)
        background: path.resolve(__dirname, "src/background/index.ts"),
        content_inject: path.resolve(__dirname, "src/content/inject.ts"),
        content_bridge: path.resolve(__dirname, "src/content/bridge.ts"),
        provider: path.resolve(__dirname, "src/provider/index.ts"),
      },
      output: {
        // Keep stable, readable paths for MV3 references
        entryFileNames: (chunk) => {
          if (chunk.name === "background") return "background.js";
          if (chunk.name === "content_bridge") return "content/bridge.js";
          if (chunk.name === "content_inject") return "content/inject.js";
          if (chunk.name === "provider") return "provider.js";
          // HTML page scripts get hashed; they’re referenced by the HTML itself
          return "assets/[name]-[hash].js";
        },
        chunkFileNames: "chunks/[name]-[hash].js",
        assetFileNames: (assetInfo) => {
          const ext = assetInfo.name?.split(".").pop() || "asset";
          // fonts/images/css from the UI
          return `assets/[name]-[hash].${ext}`;
        }
      }
    }
  },
  server: {
    // Dev convenience; scripts/dev.ts handles MV3 reload, this just serves HMR for UIs
    port: 5173,
    strictPort: true,
    hmr: { overlay: true }
  },
  worker: {
    // MV3-compatible module workers (used by src/workers/*.worker.ts)
    format: "es"
  }
}));
