{
  "$schema": "https://animica.dev/specs/studio-snippets.schema.json",
  "language": "python",
  "snippets": [
    {
      "id": "provider.fastapi.bootstrap",
      "title": "FastAPI app with health and metrics",
      "description": "Minimal FastAPI app exposing /healthz and optional /metrics (Prometheus).",
      "tags": ["fastapi", "bootstrap", "health", "metrics"],
      "scope": "provider/py",
      "body": [
        "from fastapi import FastAPI",
        "from starlette.responses import Response",
        "try:",
        "    from prometheus_client import CONTENT_TYPE_LATEST, CollectorRegistry, Counter, Histogram, generate_latest",
        "    REGISTRY = CollectorRegistry()",
        "    REQUESTS = Counter('provider_requests_total', 'HTTP requests', ['method', 'route', 'status'], registry=REGISTRY)",
        "    LATENCY = Histogram('provider_request_seconds', 'Request latency', ['route'], registry=REGISTRY)",
        "    HAVE_PROM = True",
        "except Exception:",
        "    HAVE_PROM = False",
        "",
        "app = FastAPI(title='AICF Provider')",
        "",
        "@app.get('/healthz')",
        "def healthz():",
        "    return {'ok': True}",
        "",
        "@app.get('/metrics')",
        "def metrics():",
        "    if not HAVE_PROM:",
        "        return Response('prometheus_client not installed', media_type='text/plain')",
        "    data = generate_latest(REGISTRY)",
        "    return Response(content=data, media_type=CONTENT_TYPE_LATEST)"
      ]
    },
    {
      "id": "provider.models.pydantic",
      "title": "Pydantic job models",
      "description": "Typed request/response models for jobs with safe defaults.",
      "tags": ["pydantic", "models", "typing"],
      "scope": "provider/py",
      "body": [
        "from typing import Any, Dict, Optional",
        "from pydantic import BaseModel, Field",
        "",
        "class JobRequest(BaseModel):",
        "    job_id: str = Field(..., description='Unique job identifier')",
        "    kind: str = Field(..., description='Task kind (e.g., ai.infer, quantum.run)')",
        "    payload: Dict[str, Any] = Field(default_factory=dict)",
        "    priority: int = 0",
        "    deadline_s: Optional[int] = Field(None, ge=1, description='Soft deadline in seconds')",
        "",
        "class JobResult(BaseModel):",
        "    job_id: str",
        "    status: str = Field(..., regex='^(ok|error)$')",
        "    result: Optional[Dict[str, Any]] = None",
        "    error: Optional[str] = None",
        "    duration_ms: int = Field(..., ge=0)"
      ]
    },
    {
      "id": "provider.config.settings",
      "title": "Settings via BaseSettings",
      "description": "Load provider configuration from environment (.env supported).",
      "tags": ["config", "settings", "env"],
      "scope": "provider/py",
      "body": [
        "from pydantic import BaseSettings",
        "",
        "class Settings(BaseSettings):",
        "    PORT: int = 8080",
        "    LOG_LEVEL: str = 'INFO'",
        "    SERVICES_URL: str = 'http://localhost:8547'", 
        "    RPC_URL: str = 'http://localhost:8545'",
        "    PROVIDER_SECRET: str = 'change-me'", 
        "    MAX_CONCURRENCY: int = 2",
        "",
        "    class Config:",
        "        env_prefix = 'AICF_'",
        "        env_file = '.env'",
        "",
        "settings = Settings()"
      ]
    },
    {
      "id": "provider.security.hmac",
      "title": "Verify HMAC signature header",
      "description": "Validate a sha256= header using shared secret.",
      "tags": ["security", "hmac", "webhook"],
      "scope": "provider/py",
      "body": [
        "import hmac, hashlib",
        "",
        "def verify_hmac(signature_header: str, body: bytes, secret: str) -> bool:",
        "    try:",
        "        scheme, given = signature_header.split('=', 1)",
        "    except ValueError:",
        "        return False",
        "    if scheme.lower() != 'sha256':",
        "        return False",
        "    mac = hmac.new(secret.encode(), body, hashlib.sha256).hexdigest()",
        "    return hmac.compare_digest(mac, given)"
      ]
    },
    {
      "id": "provider.queue.asyncio",
      "title": "Asyncio queue & worker loop",
      "description": "In-memory queue with a cancellable worker loop.",
      "tags": ["queue", "asyncio", "worker"],
      "scope": "provider/py",
      "body": [
        "import asyncio, time",
        "from typing import Awaitable, Callable",
        "",
        "job_queue: asyncio.Queue = asyncio.Queue()",
        "",
        "async def enqueue(job) -> None:",
        "    await job_queue.put(job)",
        "",
        "async def worker_loop(handler: Callable[[object], Awaitable[None]]):",
        "    while True:",
        "        job = await job_queue.get()",
        "        try:",
        "            await handler(job)",
        "        finally:",
        "            job_queue.task_done()"
      ]
    },
    {
      "id": "provider.routes.submit",
      "title": "FastAPI /submit endpoint",
      "description": "Accept jobs, verify HMAC, enqueue.",
      "tags": ["fastapi", "routes", "hmac", "queue"],
      "scope": "provider/py",
      "body": [
        "from fastapi import Request, HTTPException",
        "from .models import JobRequest",
        "from .config import settings",
        "from .security import verify_hmac",
        "from .queue import enqueue",
        "",
        "@app.post('/submit')",
        "async def submit(req: Request):",
        "    raw = await req.body()",
        "    sig = req.headers.get('x-signature', '')",
        "    if not verify_hmac(sig, raw, settings.PROVIDER_SECRET):",
        "        raise HTTPException(status_code=401, detail='invalid signature')",
        "    job = JobRequest.model_validate_json(raw)",
        "    await enqueue(job)",
        "    return {'accepted': True, 'job_id': job.job_id}"
      ]
    },
    {
      "id": "provider.worker.handler",
      "title": "Sample job handler",
      "description": "Simulated compute with per-kind dispatch & timing.",
      "tags": ["worker", "handler", "timing"],
      "scope": "provider/py",
      "body": [
        "import asyncio, time, json",
        "from typing import Dict, Any",
        "from .models import JobRequest, JobResult",
        "",
        "async def do_ai_infer(payload: Dict[str, Any]) -> Dict[str, Any]:",
        "    await asyncio.sleep(0.25)",
        "    return {'summary': payload.get('text', '')[::-1]}",
        "",
        "async def do_quantum_run(payload: Dict[str, Any]) -> Dict[str, Any]:",
        "    await asyncio.sleep(0.15)",
        "    return {'bytes': 'deadbeef', 'shots': payload.get('shots', 16)}",
        "",
        "async def handle_job(job: JobRequest) -> JobResult:",
        "    t0 = time.perf_counter()",
        "    try:",
        "        if job.kind == 'ai.infer':",
        "            out = await do_ai_infer(job.payload)",
        "        elif job.kind == 'quantum.run':",
        "            out = await do_quantum_run(job.payload)",
        "        else:",
        "            raise ValueError(f'unknown kind: {job.kind}')",
        "        status, error = 'ok', None",
        "        result = out",
        "    except Exception as exc:",
        "        status, result, error = 'error', None, str(exc)",
        "    dur_ms = int((time.perf_counter() - t0) * 1000)",
        "    return JobResult(job_id=job.job_id, status=status, result=result, error=error, duration_ms=dur_ms)"
      ]
    },
    {
      "id": "provider.webhook.post_result",
      "title": "Post result to services with retries",
      "description": "HTTPX client with exponential backoff and jitter.",
      "tags": ["httpx", "retry", "backoff"],
      "scope": "provider/py",
      "body": [
        "import asyncio, json, random",
        "import httpx",
        "from .config import settings",
        "from .models import JobResult",
        "",
        "async def post_with_retries(url: str, json_body: dict, attempts: int = 5) -> None:",
        "    delay = 0.25",
        "    async with httpx.AsyncClient(timeout=10) as client:",
        "        for i in range(attempts):",
        "            try:",
        "                r = await client.post(url, json=json_body)",
        "                r.raise_for_status()",
        "                return",
        "            except Exception:",
        "                if i == attempts - 1:",
        "                    raise",
        "                await asyncio.sleep(delay + random.random() * 0.1)",
        "                delay *= 2",
        "",
        "async def send_result(res: JobResult) -> None:",
        "    url = f\"{settings.SERVICES_URL}/provider/result\"",
        "    await post_with_retries(url, json_body=json.loads(res.model_dump_json()))"
      ]
    },
    {
      "id": "provider.metrics.prom",
      "title": "Task metrics (Prometheus)",
      "description": "Counters and histograms for tasks; use in handler/submit.",
      "tags": ["metrics", "prometheus"],
      "scope": "provider/py",
      "body": [
        "try:",
        "    from prometheus_client import Counter, Histogram, CollectorRegistry",
        "    from .app import REGISTRY",
        "    TASKS = Counter('provider_tasks_total', 'Tasks processed', ['kind', 'status'], registry=REGISTRY)",
        "    TASK_LAT = Histogram('provider_task_seconds', 'Task duration', ['kind'], registry=REGISTRY)",
        "except Exception:",
        "    TASKS = None",
        "    TASK_LAT = None",
        "",
        "def observe(kind: str, status: str, seconds: float):",
        "    if TASKS and TASK_LAT:",
        "        TASKS.labels(kind=kind, status=status).inc()",
        "        TASK_LAT.labels(kind=kind).observe(seconds)"
      ]
    },
    {
      "id": "provider.logging.json",
      "title": "Structured JSON logging",
      "description": "Basic JSON logs compatible with Loki.",
      "tags": ["logging", "json", "observability"],
      "scope": "provider/py",
      "body": [
        "import json, logging, sys, time",
        "",
        "class JsonFormatter(logging.Formatter):",
        "    def format(self, record):",
        "        base = {",
        "            'level': record.levelname,",
        "            'ts': time.time(),",
        "            'msg': record.getMessage(),",
        "            'name': record.name",
        "        }",
        "        if record.exc_info:",
        "            base['exc'] = self.formatException(record.exc_info)",
        "        return json.dumps(base)",
        "",
        "def setup_logging(level: str = 'INFO'):",
        "    h = logging.StreamHandler(sys.stdout)",
        "    h.setFormatter(JsonFormatter())",
        "    root = logging.getLogger()",
        "    root.handlers = [h]",
        "    root.setLevel(level)"
      ]
    },
    {
      "id": "provider.fastapi.startup_worker",
      "title": "Start background worker on startup",
      "description": "Launch worker task and mark readiness.",
      "tags": ["fastapi", "startup", "worker"],
      "scope": "provider/py",
      "body": [
        "import asyncio",
        "from fastapi import FastAPI",
        "from .worker import handle_job",
        "from .queue import worker_loop",
        "",
        "app_state = {'ready': False, 'task': None}",
        "",
        "@app.on_event('startup')",
        "async def on_start():",
        "    app_state['task'] = asyncio.create_task(worker_loop(handle_job))",
        "    app_state['ready'] = True",
        "",
        "@app.on_event('shutdown')",
        "async def on_stop():",
        "    task = app_state.get('task')",
        "    if task:",
        "        task.cancel()",
        "        with contextlib.suppress(Exception):",
        "            await task"
      ]
    },
    {
      "id": "provider.readiness",
      "title": "Readiness endpoint",
      "description": "Report readiness based on worker startup.",
      "tags": ["k8s", "readiness", "health"],
      "scope": "provider/py",
      "body": [
        "from fastapi import Response, status",
        "from .startup import app_state",
        "",
        "@app.get('/readyz')",
        "def readyz():",
        "    if app_state.get('ready'):",
        "        return {'ready': True}",
        "    return Response(status_code=status.HTTP_503_SERVICE_UNAVAILABLE)"
      ]
    },
    {
      "id": "provider.retry.backoff",
      "title": "Exponential backoff helper",
      "description": "Retry a coroutine with capped exponential backoff and jitter.",
      "tags": ["retry", "backoff", "asyncio"],
      "scope": "provider/py",
      "body": [
        "import asyncio, random",
        "from typing import Callable, Awaitable, TypeVar",
        "",
        "T = TypeVar('T')",
        "",
        "async def retry(fn: Callable[[], Awaitable[T]], attempts: int = 5, initial: float = 0.2, cap: float = 5.0) -> T:",
        "    delay = initial",
        "    for i in range(attempts):",
        "        try:",
        "            return await fn()",
        "        except Exception:",
        "            if i == attempts - 1:",
        "                raise",
        "            await asyncio.sleep(min(cap, delay) + random.random() * 0.1)",
        "            delay *= 2"
      ]
    },
    {
      "id": "provider.da.client",
      "title": "Post blob to DA & get commitment",
      "description": "Simple DA client that posts bytes and returns a commitment.",
      "tags": ["da", "httpx", "commitment"],
      "scope": "provider/py",
      "body": [
        "import hashlib, httpx",
        "",
        "async def post_blob(da_url: str, data: bytes) -> dict:",
        "    commit = hashlib.sha256(data).hexdigest()",
        "    async with httpx.AsyncClient(timeout=15) as client:",
        "        r = await client.post(f'{da_url}/blob', content=data, headers={'x-commitment': commit})",
        "        r.raise_for_status()",
        "        return {'commitment': commit, 'id': r.json().get('id')}"
      ]
    },
    {
      "id": "provider.rate_limit.memory",
      "title": "In-memory sliding window rate limiter",
      "description": "Best-effort limiter keyed by client id.",
      "tags": ["rate-limit", "security"],
      "scope": "provider/py",
      "body": [
        "import time",
        "from collections import deque, defaultdict",
        "",
        "WINDOW_S, MAX_REQ = 60, 120",
        "HITS = defaultdict(deque)",
        "",
        "def allow(key: str) -> bool:",
        "    now = time.time()",
        "    dq = HITS[key]",
        "    while dq and now - dq[0] > WINDOW_S:",
        "        dq.popleft()",
        "    if len(dq) >= MAX_REQ:",
        "        return False",
        "    dq.append(now)",
        "    return True"
      ]
    },
    {
      "id": "provider.routes.submit_with_rl",
      "title": "Submit with rate limiting",
      "description": "Extend /submit to enforce rate limits by client-id.",
      "tags": ["fastapi", "rate-limit"],
      "scope": "provider/py",
      "body": [
        "from fastapi import Header",
        "from .ratelimit import allow",
        "",
        "@app.post('/submit')",
        "async def submit(req: Request, client_id: str = Header(default='anon', alias='x-client-id')):",
        "    if not allow(client_id):",
        "        raise HTTPException(status_code=429, detail='rate limit exceeded')",
        "    raw = await req.body()",
        "    sig = req.headers.get('x-signature', '')",
        "    if not verify_hmac(sig, raw, settings.PROVIDER_SECRET):",
        "        raise HTTPException(status_code=401, detail='invalid signature')",
        "    job = JobRequest.model_validate_json(raw)",
        "    await enqueue(job)",
        "    return {'accepted': True, 'job_id': job.job_id}"
      ]
    }
  ]
}
