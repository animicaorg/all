{
  "$schema": "https://animica.dev/specs/studio-snippets.schema.json",
  "language": "typescript",
  "snippets": [
    {
      "id": "dapp.provider.detect",
      "title": "Detect EIP-1193 provider & chain",
      "description": "Safely detect an injected EIP-1193 provider (e.g., wallet/extension), fetch chainId, and accounts.",
      "tags": ["provider", "wallet", "eip1193", "basics"],
      "scope": "dapp/ts",
      "body": [
        "export async function detectProvider() {",
        "  const anyWindow = window as unknown as { ethereum?: any };",
        "  const provider = anyWindow.ethereum;",
        "  if (!provider) throw new Error(\"No EIP-1193 provider detected (is the wallet/extension installed?)\");",
        "  const [chainIdHex, accounts] = await Promise.all([",
        "    provider.request({ method: \"eth_chainId\" }),",
        "    provider.request({ method: \"eth_accounts\" })",
        "  ]);",
        "  const chainId = Number(chainIdHex);",
        "  return { provider, chainId, accounts };",
        "}"
      ]
    },
    {
      "id": "dapp.wallet.connect_button",
      "title": "ConnectButton (React)",
      "description": "Minimal connect button that requests accounts and shows the active address.",
      "tags": ["react", "wallet", "ui"],
      "scope": "dapp/react-ts",
      "body": [
        "import React from \"react\";",
        "",
        "export function ConnectButton() {",
        "  const [address, setAddress] = React.useState<string | null>(null);",
        "",
        "  async function connect() {",
        "    const eth = (window as any).ethereum;",
        "    if (!eth) return alert(\"No wallet detected\");",
        "    const accounts = await eth.request({ method: \"eth_requestAccounts\" });",
        "    setAddress(accounts?.[0] ?? null);",
        "  }",
        "",
        "  return (",
        "    <button onClick={connect} style={{ padding: 8 }}>",
        "      {address ? `Connected: ${address.slice(0, 6)}…${address.slice(-4)}` : \"Connect Wallet\"}",
        "    </button>",
        "  );",
        "}"
      ]
    },
    {
      "id": "dapp.security.require_chain",
      "title": "Require specific chainId and prompt switch",
      "description": "Ensure user is on the expected chain; attempts wallet_switchEthereumChain if not.",
      "tags": ["wallet", "chain", "security"],
      "scope": "dapp/ts",
      "body": [
        "export async function ensureChain(expectedHexChainId: string) {",
        "  const provider = (window as any).ethereum;",
        "  if (!provider) throw new Error(\"No provider\");",
        "  const current = await provider.request({ method: \"eth_chainId\" });",
        "  if (current?.toLowerCase() === expectedHexChainId.toLowerCase()) return true;",
        "  try {",
        "    await provider.request({",
        "      method: \"wallet_switchEthereumChain\",",
        "      params: [{ chainId: expectedHexChainId }]",
        "    });",
        "    return true;",
        "  } catch (err: any) {",
        "    // Optionally handle wallet_addEthereumChain here if chain is unknown",
        "    throw err;",
        "  }",
        "}"
      ]
    },
    {
      "id": "dapp.rpc.client",
      "title": "HTTP JSON-RPC client",
      "description": "Tiny RPC client for calling node HTTP endpoints directly.",
      "tags": ["rpc", "http", "utility"],
      "scope": "dapp/ts",
      "body": [
        "type JsonRpcRequest = { jsonrpc: \"2.0\"; id: number; method: string; params?: unknown[] };",
        "type JsonRpcResponse<T> = { jsonrpc: \"2.0\"; id: number; result?: T; error?: { code: number; message: string } };",
        "",
        "let rpcId = 1;",
        "export async function rpc<T = any>(endpoint: string, method: string, params: unknown[] = []) {",
        "  const payload: JsonRpcRequest = { jsonrpc: \"2.0\", id: rpcId++, method, params };",
        "  const res = await fetch(endpoint, {",
        "    method: \"POST\",",
        "    headers: { \"content-type\": \"application/json\" },",
        "    body: JSON.stringify(payload)",
        "  });",
        "  const data = (await res.json()) as JsonRpcResponse<T>;",
        "  if (data.error) throw new Error(`${data.error.code}: ${data.error.message}`);",
        "  return data.result as T;",
        "}"
      ]
    },
    {
      "id": "dapp.ws.subscribe_newHeads",
      "title": "WebSocket: subscribe to newHeads",
      "description": "Subscribes to newHeads via eth_subscribe and cleans up on unmount.",
      "tags": ["ws", "subscription", "headers", "react"],
      "scope": "dapp/react-ts",
      "body": [
        "import React from \"react\";",
        "",
        "export function useNewHeads(wsUrl: string) {",
        "  const [head, setHead] = React.useState<any | null>(null);",
        "",
        "  React.useEffect(() => {",
        "    let ws: WebSocket | null = new WebSocket(wsUrl);",
        "    let subId: string | null = null;",
        "",
        "    ws.onopen = () => {",
        "      ws?.send(JSON.stringify({",
        "        jsonrpc: \"2.0\", id: 1, method: \"eth_subscribe\", params: [\"newHeads\"]",
        "      }));",
        "    };",
        "",
        "    ws.onmessage = (ev) => {",
        "      const msg = JSON.parse(ev.data);",
        "      if (msg.id === 1 && msg.result && typeof msg.result === \"string\") {",
        "        subId = msg.result;",
        "      } else if (msg.method === \"eth_subscription\" && msg.params) {",
        "        setHead(msg.params.result);",
        "      }",
        "    };",
        "",
        "    return () => {",
        "      try {",
        "        if (ws && subId) {",
        "          ws.send(JSON.stringify({",
        "            jsonrpc: \"2.0\", id: 2, method: \"eth_unsubscribe\", params: [subId]",
        "          }));",
        "        }",
        "      } catch {}",
        "      ws?.close();",
        "      ws = null;",
        "    };",
        "  }, [wsUrl]);",
        "",
        "  return head;",
        "}"
      ]
    },
    {
      "id": "dapp.tx.send",
      "title": "Send transaction via provider",
      "description": "Send a transaction with the connected EIP-1193 provider using eth_sendTransaction.",
      "tags": ["tx", "wallet", "provider"],
      "scope": "dapp/ts",
      "body": [
        "export async function sendTx(tx: { from: string; to?: string; value?: string; data?: string; gas?: string; gasPrice?: string }) {",
        "  const provider = (window as any).ethereum;",
        "  if (!provider) throw new Error(\"No provider\");",
        "  const hash = await provider.request({ method: \"eth_sendTransaction\", params: [tx] });",
        "  return hash as string;",
        "}"
      ]
    },
    {
      "id": "dapp.tx.wait_for_receipt",
      "title": "Wait for transaction receipt (poll)",
      "description": "Polls eth_getTransactionReceipt until mined or timeout reached.",
      "tags": ["tx", "receipt", "rpc"],
      "scope": "dapp/ts",
      "body": [
        "export async function waitForReceipt(rpcUrl: string, hash: string, { intervalMs = 1500, timeoutMs = 120000 } = {}) {",
        "  const start = Date.now();",
        "  while (Date.now() - start < timeoutMs) {",
        "    const res = await fetch(rpcUrl, {",
        "      method: \"POST\",",
        "      headers: { \"content-type\": \"application/json\" },",
        "      body: JSON.stringify({ jsonrpc: \"2.0\", id: 1, method: \"eth_getTransactionReceipt\", params: [hash] })",
        "    });",
        "    const json = await res.json();",
        "    if (json?.result) return json.result;",
        "    await new Promise(r => setTimeout(r, intervalMs));",
        "  }",
        "  throw new Error(\"Timed out waiting for receipt\");",
        "}"
      ]
    },
    {
      "id": "dapp.contract.read_viem",
      "title": "Contract read (viem)",
      "description": "Uses viem to perform a read-only contract call with a minimal ABI.",
      "tags": ["contracts", "viem", "read"],
      "scope": "dapp/ts",
      "body": [
        "// npm i viem",
        "import { createPublicClient, http, parseAbi } from \"viem\";",
        "",
        "export async function readCounter(rpcUrl: string, addr: `0x${string}`) {",
        "  const client = createPublicClient({ transport: http(rpcUrl) });",
        "  const abi = parseAbi([\"function get() view returns (uint256)\"]);",
        "  const value = await client.readContract({ address: addr, abi, functionName: \"get\" });",
        "  return value as bigint;",
        "}"
      ]
    },
    {
      "id": "dapp.contract.write_viem",
      "title": "Contract write (viem + wallet client)",
      "description": "Uses viem's wallet client bound to an EIP-1193 provider to send a write.",
      "tags": ["contracts", "viem", "write", "wallet"],
      "scope": "dapp/ts",
      "body": [
        "// npm i viem",
        "import { createWalletClient, custom, parseAbi, hexToBigInt } from \"viem\";",
        "",
        "export async function incrementCounter(addr: `0x${string}`) {",
        "  const eth = (window as any).ethereum;",
        "  if (!eth) throw new Error(\"No wallet\");",
        "  const [account] = await eth.request({ method: \"eth_requestAccounts\" });",
        "  const wallet = createWalletClient({ transport: custom(eth) });",
        "  const abi = parseAbi([\"function inc()\"]);",
        "  const hash = await wallet.writeContract({ address: addr, abi, functionName: \"inc\", account });",
        "  return hash as `0x${string}`;",
        "}"
      ]
    },
    {
      "id": "dapp.logs.decode_event_viem",
      "title": "Decode event logs (viem)",
      "description": "Parse a Transfer(address,address,uint256) log using viem utilities.",
      "tags": ["logs", "events", "viem"],
      "scope": "dapp/ts",
      "body": [
        "import { parseAbiItem, decodeEventLog } from \"viem\";",
        "",
        "const Transfer = parseAbiItem(\"event Transfer(address indexed from, address indexed to, uint256 amount)\");",
        "",
        "export function decodeTransfer(log: { topics: string[]; data: `0x${string}`; address: `0x${string}` }) {",
        "  return decodeEventLog({ abi: [Transfer], ...log });",
        "}"
      ]
    },
    {
      "id": "dapp.react.useInterval",
      "title": "useInterval hook",
      "description": "Declarative setInterval for polling (cleans up on unmount).",
      "tags": ["react", "hooks", "polling"],
      "scope": "dapp/react-ts",
      "body": [
        "import React from \"react\";",
        "",
        "export function useInterval(cb: () => void, delayMs: number | null) {",
        "  const saved = React.useRef(cb);",
        "  React.useEffect(() => { saved.current = cb; }, [cb]);",
        "  React.useEffect(() => {",
        "    if (delayMs === null) return;",
        "    const id = setInterval(() => saved.current(), delayMs);",
        "    return () => clearInterval(id);",
        "  }, [delayMs]);",
        "}"
      ]
    },
    {
      "id": "dapp.ui.TxStatus",
      "title": "TxStatus component",
      "description": "Simple transaction status view: hash link + receipt summary.",
      "tags": ["react", "ui", "tx"],
      "scope": "dapp/react-ts",
      "body": [
        "import React from \"react\";",
        "",
        "type Props = {",
        "  hash?: string | null;",
        "  receipt?: any | null;",
        "  explorerTxUrl?: (h: string) => string;",
        "};",
        "",
        "export function TxStatus({ hash, receipt, explorerTxUrl }: Props) {",
        "  if (!hash) return null;",
        "  const status = receipt ? (receipt.status === \"0x1\" ? \"Success\" : \"Failed\") : \"Pending\";",
        "  return (",
        "    <div style={{ padding: 8, border: \"1px solid #ccc\", borderRadius: 6, marginTop: 8 }}>",
        "      <div><strong>Tx:</strong> {explorerTxUrl ? <a href={explorerTxUrl(hash)} target=\"_blank\" rel=\"noreferrer\">{hash}</a> : hash}</div>",
        "      <div><strong>Status:</strong> {status}</div>",
        "      {receipt && (",
        "        <div style={{ marginTop: 6, fontSize: 12, opacity: 0.8 }}>",
        "          block: {parseInt(receipt.blockNumber)} · gasUsed: {parseInt(receipt.gasUsed)}",
        "        </div>",
        "      )}",
        "    </div>",
        "  );",
        "}"
      ]
    },
    {
      "id": "dapp.utils.format",
      "title": "Format helpers",
      "description": "Shorten addresses and format bigints/hex.",
      "tags": ["utils", "format"],
      "scope": "dapp/ts",
      "body": [
        "export const shortAddr = (a?: string | null, n = 4) => a ? `${a.slice(0, 2 + n)}…${a.slice(-n)}` : \"\";",
        "export const hexToDec = (h: string) => BigInt(h).toString(10);",
        "export const toHex = (v: bigint) => \"0x\" + v.toString(16);"
      ]
    },
    {
      "id": "dapp.state.persist_address",
      "title": "Persist last connected address",
      "description": "Store and load the last address from localStorage.",
      "tags": ["state", "storage", "wallet"],
      "scope": "dapp/ts",
      "body": [
        "const KEY = \"animica:lastAddress\";",
        "export const saveAddress = (addr: string) => localStorage.setItem(KEY, addr);",
        "export const loadAddress = () => localStorage.getItem(KEY);"
      ]
    },
    {
      "id": "dapp.rpc.batch",
      "title": "RPC batch requests",
      "description": "Send multiple JSON-RPC calls in a single HTTP request.",
      "tags": ["rpc", "batch", "http"],
      "scope": "dapp/ts",
      "body": [
        "export async function rpcBatch(endpoint: string, calls: { method: string; params?: unknown[] }[]) {",
        "  let id = 1;",
        "  const payload = calls.map(c => ({ jsonrpc: \"2.0\", id: id++, method: c.method, params: c.params ?? [] }));",
        "  const res = await fetch(endpoint, {",
        "    method: \"POST\",",
        "    headers: { \"content-type\": \"application/json\" },",
        "    body: JSON.stringify(payload)",
        "  });",
        "  return res.json();",
        "}"
      ]
    },
    {
      "id": "dapp.mempool.pending_ws",
      "title": "WebSocket: pendingTxs stream",
      "description": "Subscribe to pending transactions (if the node exposes pendingTxs).",
      "tags": ["ws", "mempool", "subscriptions"],
      "scope": "dapp/react-ts",
      "body": [
        "import React from \"react\";",
        "",
        "export function usePendingTxs(wsUrl: string) {",
        "  const [hashes, setHashes] = React.useState<string[]>([]);",
        "",
        "  React.useEffect(() => {",
        "    const ws = new WebSocket(wsUrl);",
        "    let subId: string | null = null;",
        "",
        "    ws.onopen = () => {",
        "      ws.send(JSON.stringify({ jsonrpc: \"2.0\", id: 1, method: \"eth_subscribe\", params: [\"newPendingTransactions\"] }));",
        "    };",
        "",
        "    ws.onmessage = (ev) => {",
        "      const msg = JSON.parse(ev.data);",
        "      if (msg.id === 1 && typeof msg.result === \"string\") subId = msg.result;",
        "      if (msg.method === \"eth_subscription\" && msg.params?.result) {",
        "        setHashes(prev => [msg.params.result as string, ...prev].slice(0, 50));",
        "      }",
        "    };",
        "",
        "    return () => {",
        "      try { if (subId) ws.send(JSON.stringify({ jsonrpc: \"2.0\", id: 2, method: \"eth_unsubscribe\", params: [subId] })); } catch {}",
        "      ws.close();",
        "    };",
        "  }, [wsUrl]);",
        "",
        "  return hashes;",
        "}"
      ]
    },
    {
      "id": "dapp.contract.minimal_call_raw",
      "title": "Minimal raw eth_call",
      "description": "Perform a read-only eth_call when you already have call data (encoded).",
      "tags": ["rpc", "contracts", "read"],
      "scope": "dapp/ts",
      "body": [
        "export async function ethCall(rpcUrl: string, to: string, data: string, blockTag: string = \"latest\") {",
        "  const res = await fetch(rpcUrl, {",
        "    method: \"POST\",",
        "    headers: { \"content-type\": \"application/json\" },",
        "    body: JSON.stringify({ jsonrpc: \"2.0\", id: 1, method: \"eth_call\", params: [{ to, data }, blockTag] })",
        "  });",
        "  const json = await res.json();",
        "  if (json.error) throw new Error(json.error.message);",
        "  return json.result as string;",
        "}"
      ]
    },
    {
      "id": "dapp.fees.estimate_gas",
      "title": "Estimate gas & maxFee setup",
      "description": "Get gas estimate and set EIP-1559 fee fields before sending a tx.",
      "tags": ["fees", "gas", "tx"],
      "scope": "dapp/ts",
      "body": [
        "export async function prepareFeesAndGas(rpcUrl: string, tx: Record<string, any>) {",
        "  const [estimate, fee] = await Promise.all([",
        "    fetch(rpcUrl, {",
        "      method: \"POST\",",
        "      headers: { \"content-type\": \"application/json\" },",
        "      body: JSON.stringify({ jsonrpc: \"2.0\", id: 1, method: \"eth_estimateGas\", params: [tx] })",
        "    }).then(r => r.json()),",
        "    fetch(rpcUrl, {",
        "      method: \"POST\",",
        "      headers: { \"content-type\": \"application/json\" },",
        "      body: JSON.stringify({ jsonrpc: \"2.0\", id: 2, method: \"eth_maxPriorityFeePerGas\", params: [] })",
        "    }).then(r => r.json())",
        "  ]);",
        "  if (estimate.error) throw new Error(estimate.error.message);",
        "  const gas = estimate.result;",
        "  const maxPriorityFeePerGas = fee.result;",
        "  // Optional: eth_feeHistory or baseFee from latest block for maxFeePerGas",
        "  return { gas, maxPriorityFeePerGas };",
        "}"
      ]
    },
    {
      "id": "dapp.react.env_config",
      "title": "Vite env config",
      "description": "Read RPC/WS endpoints from Vite env variables.",
      "tags": ["env", "vite", "config"],
      "scope": "dapp/ts",
      "body": [
        "export const RPC_URL = import.meta.env.VITE_RPC_URL as string;",
        "export const WS_URL = import.meta.env.VITE_WS_URL as string;",
        "export const EXPLORER_TX = (h: string) => `${import.meta.env.VITE_EXPLORER_BASE}/tx/${h}`;"
      ]
    },
    {
      "id": "dapp.state.useProviderEvents",
      "title": "useProviderEvents (accounts/chain changed)",
      "description": "React hook that subscribes to provider events and updates state.",
      "tags": ["react", "wallet", "events"],
      "scope": "dapp/react-ts",
      "body": [
        "import React from \"react\";",
        "",
        "export function useProviderEvents() {",
        "  const [account, setAccount] = React.useState<string | null>(null);",
        "  const [chainId, setChainId] = React.useState<string | null>(null);",
        "",
        "  React.useEffect(() => {",
        "    const eth = (window as any).ethereum;",
        "    if (!eth) return;",
        "    const onAccounts = (accs: string[]) => setAccount(accs?.[0] ?? null);",
        "    const onChain = (cid: string) => setChainId(cid);",
        "    eth.request({ method: \"eth_accounts\" }).then((accs: string[]) => onAccounts(accs));",
        "    eth.request({ method: \"eth_chainId\" }).then((cid: string) => onChain(cid));",
        "    eth.on?.(\"accountsChanged\", onAccounts);",
        "    eth.on?.(\"chainChanged\", onChain);",
        "    return () => {",
        "      eth.removeListener?.(\"accountsChanged\", onAccounts);",
        "      eth.removeListener?.(\"chainChanged\", onChain);",
        "    };",
        "  }, []);",
        "",
        "  return { account, chainId };",
        "}"
      ]
    }
  ]
}
