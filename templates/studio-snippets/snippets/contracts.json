{
  "$schema": "https://animica.dev/specs/studio-snippets.schema.json",
  "language": "python",
  "snippets": [
    {
      "id": "contract.counter.get",
      "title": "Counter: getter (read-only)",
      "description": "Minimal deterministic getter that reads an int from storage and returns 0 if unset.",
      "tags": ["contracts", "storage", "read-only"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import storage",
        "",
        "def get() -> int:",
        "    n = storage.get(b\"counter\")",
        "    return n if n is not None else 0"
      ]
    },
    {
      "id": "contract.counter.inc",
      "title": "Counter: increment + event",
      "description": "Increments a stored counter and emits an event with the new value.",
      "tags": ["contracts", "storage", "events", "write"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import storage, events",
        "",
        "def inc() -> None:",
        "    n = storage.get(b\"counter\") or 0",
        "    n = n + 1",
        "    storage.set(b\"counter\", n)",
        "    events.emit(b\"Inc\", {b\"new\": n})"
      ]
    },
    {
      "id": "contract.abi.require",
      "title": "Defensive checks with abi.require",
      "description": "Use abi.require for precondition checks that revert on failure with a short, stable message.",
      "tags": ["contracts", "abi", "defensive"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import abi, storage",
        "",
        "def set_nonzero(key: bytes, value: int) -> None:",
        "    abi.require(len(key) > 0, b\"empty-key\")",
        "    abi.require(value != 0, b\"zero-value\")",
        "    storage.set(key, value)"
      ]
    },
    {
      "id": "contract.storage.map_key",
      "title": "Mapping key pattern (bytes prefix + address)",
      "description": "Constructs a composite key for a mapping: prefix || address.",
      "tags": ["contracts", "storage", "pattern"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import storage, abi",
        "",
        "PREFIX = b\"bal:\"  # keep short; costs propagate",
        "",
        "def _k(addr: bytes) -> bytes:",
        "    abi.require(len(addr) > 0, b\"addr\")",
        "    return PREFIX + addr",
        "",
        "def balance_of(addr: bytes) -> int:",
        "    return storage.get(_k(addr)) or 0",
        "",
        "def _set_balance(addr: bytes, amt: int) -> None:",
        "    storage.set(_k(addr), amt)"
      ]
    },
    {
      "id": "contract.token.transfer_core",
      "title": "Token transfer (core, no events/allowance)",
      "description": "Minimal safe transfer core using a mapping pattern; emits no events; add events/allowance as needed.",
      "tags": ["contracts", "token", "math", "storage"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import abi, storage",
        "",
        "BAL = b\"bal:\"",
        "",
        "def _kb(a: bytes) -> bytes: return BAL + a",
        "",
        "def _get(a: bytes) -> int: return storage.get(_kb(a)) or 0",
        "def _set(a: bytes, v: int) -> None: storage.set(_kb(a), v)",
        "",
        "def transfer(sender: bytes, to: bytes, amount: int) -> None:",
        "    abi.require(amount >= 0, b\"amt<0\")",
        "    abi.require(sender != to, b\"self\")",
        "    sb = _get(sender)",
        "    abi.require(sb >= amount, b\"bal\")",
        "    tb = _get(to)",
        "    _set(sender, sb - amount)",
        "    _set(to, tb + amount)"
      ]
    },
    {
      "id": "contract.access.ownable",
      "title": "Ownable: only_owner + transferOwnership",
      "description": "Owner storage with guard and transfer/renounce.",
      "tags": ["contracts", "access", "ownable"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import storage, abi, events",
        "",
        "OWNER = b\"own:addr\"",
        "",
        "def _owner() -> bytes:",
        "    return storage.get(OWNER) or b\"\"",
        "",
        "def _only_owner(caller: bytes) -> None:",
        "    abi.require(caller == _owner(), b\"!owner\")",
        "",
        "def set_owner(initial: bytes) -> None:",
        "    # call once in constructor/init flow",
        "    storage.set(OWNER, initial)",
        "",
        "def transfer_ownership(caller: bytes, new_owner: bytes) -> None:",
        "    _only_owner(caller)",
        "    storage.set(OWNER, new_owner)",
        "    events.emit(b\"OwnershipTransferred\", {b\"prev\": caller, b\"next\": new_owner})",
        "",
        "def renounce_ownership(caller: bytes) -> None:",
        "    _only_owner(caller)",
        "    storage.set(OWNER, b\"\")",
        "    events.emit(b\"OwnershipRenounced\", {b\"prev\": caller})"
      ]
    },
    {
      "id": "contract.control.pausable",
      "title": "Pausable: pause/unpause + whenNotPaused guard",
      "description": "Simple global pause flag with guard.",
      "tags": ["contracts", "control", "pause"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import storage, abi, events",
        "",
        "PAUSED = b\"ctrl:paused\"",
        "",
        "def _paused() -> int: return storage.get(PAUSED) or 0",
        "def _when_not_paused() -> None: abi.require(_paused() == 0, b\"paused\")",
        "",
        "def pause() -> None:",
        "    storage.set(PAUSED, 1)",
        "    events.emit(b\"Paused\", {})",
        "",
        "def unpause() -> None:",
        "    storage.set(PAUSED, 0)",
        "    events.emit(b\"Unpaused\", {})"
      ]
    },
    {
      "id": "contract.events.pattern",
      "title": "Events: canonical emission",
      "description": "Stable event naming with compact keys; avoid high-cardinality payloads.",
      "tags": ["contracts", "events"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import events, abi",
        "",
        "def log_transfer(frm: bytes, to: bytes, amt: int) -> None:",
        "    abi.require(amt >= 0, b\"amt\")",
        "    events.emit(b\"Transfer\", {b\"from\": frm, b\"to\": to, b\"amount\": amt})"
      ]
    },
    {
      "id": "contract.access.roles",
      "title": "Roles: grant/revoke/check",
      "description": "Role-based access control using bytes32 role ids.",
      "tags": ["contracts", "access", "roles"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import storage, abi",
        "",
        "ROLES = b\"role:\"  # role_prefix || role_id(32) || addr",
        "",
        "def _rk(role_id: bytes, addr: bytes) -> bytes:",
        "    abi.require(len(role_id) == 32, b\"role32\")",
        "    return ROLES + role_id + addr",
        "",
        "def has_role(role_id: bytes, addr: bytes) -> int:",
        "    return storage.get(_rk(role_id, addr)) or 0",
        "",
        "def grant_role(role_id: bytes, addr: bytes) -> None:",
        "    storage.set(_rk(role_id, addr), 1)",
        "",
        "def revoke_role(role_id: bytes, addr: bytes) -> None:",
        "    storage.set(_rk(role_id, addr), 0)",
        "",
        "def require_role(role_id: bytes, addr: bytes) -> None:",
        "    abi.require(has_role(role_id, addr) == 1, b\"!role\")"
      ]
    },
    {
      "id": "contract.cap.ai.enqueue_and_consume",
      "title": "AICF: enqueue job and store task id",
      "description": "Queues an AI job and stores task id; consumer reads result in a later call.",
      "tags": ["contracts", "capabilities", "aicf"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import storage, events, abi",
        "from stdlib.capabilities import ai_compute",
        "",
        "AICF_TASK = b\"aicf:last\"",
        "",
        "def request_ai(prompt: bytes) -> None:",
        "    abi.require(len(prompt) > 0, b\"prompt\")",
        "    task_id = ai_compute.enqueue(prompt)",
        "    storage.set(AICF_TASK, task_id)",
        "    events.emit(b\"AICFQueued\", {b\"task_id\": task_id})",
        "",
        "def consume_ai() -> bytes:",
        "    task_id = storage.get(AICF_TASK)",
        "    abi.require(task_id is not None, b\"no-task\")",
        "    result = ai_compute.read_result(task_id)",
        "    abi.require(result is not None, b\"no-result\")",
        "    events.emit(b\"AICFResult\", {b\"task_id\": task_id})",
        "    return result"
      ]
    },
    {
      "id": "contract.cap.randomness.read_mix",
      "title": "Randomness: read beacon and mix",
      "description": "Reads latest beacon and mixes with caller-provided bytes to derive a pseudo-random value (deterministic).",
      "tags": ["contracts", "capabilities", "randomness"],
      "scope": "contracts/python",
      "body": [
        "from stdlib.capabilities import randomness",
        "from stdlib import abi",
        "",
        "def draw(seed: bytes) -> bytes:",
        "    abi.require(len(seed) > 0, b\"seed\")",
        "    beacon = randomness.latest()  # bytes32",
        "    # Simple XOR mix; callers may hash upstream if needed",
        "    n = len(seed)",
        "    out = bytearray(32)",
        "    for i in range(32):",
        "        out[i] = beacon[i] ^ seed[i % n]",
        "    return bytes(out)"
      ]
    },
    {
      "id": "contract.cap.da.pin_commitment",
      "title": "DA: pin blob commitment",
      "description": "Stores a DA commitment so other contracts/clients can reference it.",
      "tags": ["contracts", "capabilities", "da"],
      "scope": "contracts/python",
      "body": [
        "from stdlib.capabilities import da_blob",
        "from stdlib import storage, abi, events",
        "",
        "DA_LAST = b\"da:last\"",
        "",
        "def pin(commitment: bytes) -> None:",
        "    abi.require(len(commitment) == 32, b\"c32\")",
        "    ok = da_blob.pin(commitment)",
        "    abi.require(ok, b\"pin\")",
        "    storage.set(DA_LAST, commitment)",
        "    events.emit(b\"DAPinned\", {b\"c\": commitment})",
        "",
        "def last_commitment() -> bytes:",
        "    c = storage.get(DA_LAST)",
        "    return c if c is not None else b\"\""
      ]
    },
    {
      "id": "contract.cap.zk.verify",
      "title": "ZK: verify proof and emit",
      "description": "Verifies a proof by on-chain syscall and emits an event on success.",
      "tags": ["contracts", "capabilities", "zk"],
      "scope": "contracts/python",
      "body": [
        "from stdlib.capabilities import zkverify",
        "from stdlib import abi, events",
        "",
        "def verify_and_log(vk_id: bytes, proof: bytes) -> None:",
        "    abi.require(len(vk_id) == 32, b\"vk32\")",
        "    abi.require(len(proof) > 0, b\"proof\")",
        "    ok = zkverify.verify(proof, vk_id)",
        "    abi.require(ok, b\"zk\")",
        "    events.emit(b\"ZKVerified\", {b\"vk\": vk_id})"
      ]
    },
    {
      "id": "contract.time.timelock.queue_exec",
      "title": "Timelock: queue + exec after delay",
      "description": "Schedules an operation hash then executes after a deterministic delay (blocktime abstraction).",
      "tags": ["contracts", "control", "timelock"],
      "scope": "contracts/python",
      "body": [
        "from stdlib import storage, abi, events",
        "",
        "TL_Q = b\"tl:q:\"  # TL_Q || op_hash",
        "TL_T = b\"tl:t:\"  # TL_T || op_hash",
        "DELAY = 10  # blocks; choose per policy",
        "",
        "def _qk(h: bytes) -> bytes: return TL_Q + h",
        "def _tk(h: bytes) -> bytes: return TL_T + h",
        "",
        "def queue(op_hash: bytes, now_height: int) -> None:",
        "    abi.require(len(op_hash) == 32, b\"h32\")",
        "    storage.set(_qk(op_hash), 1)",
        "    storage.set(_tk(op_hash), now_height + DELAY)",
        "    events.emit(b\"Queued\", {b\"h\": op_hash})",
        "",
        "def execute(op_hash: bytes, now_height: int) -> None:",
        "    abi.require(storage.get(_qk(op_hash)) == 1, b\"!q\")",
        "    due = storage.get(_tk(op_hash)) or 0",
        "    abi.require(now_height >= due, b\"!due\")",
        "    # Perform the associated operation here (by convention in your contract).",
        "    storage.set(_qk(op_hash), 0)",
        "    events.emit(b\"Executed\", {b\"h\": op_hash})"
      ]
    }
  ]
}
