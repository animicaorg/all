import React, { CSSProperties, ReactElement, ReactNode, useId } from "react";

/**
 * Accessible, composable form field wrapper.
 *
 * Usage (simple):
 *   <Field label="Address" hint="Bech32 with pq prefix" error={err} required>
 *     <input value={addr} onChange={...} />
 *   </Field>
 *
 * Usage (render-prop for custom controls):
 *   <Field label="Amount" required>
 *     {(a11y) => <MyNumberInput {...a11y} value={amt} onChange={...} />}
 *   </Field>
 *
 * Notes:
 * - Ensures label â†” control association via htmlFor/id
 * - Wires aria-describedby to hint + error for screen readers
 * - Sets aria-invalid/aria-required when relevant
 * - Adds data-invalid / data-required attributes for styling hooks
 */

export type ControlA11yProps = {
  id: string;
  "aria-invalid"?: boolean;
  "aria-required"?: boolean;
  "aria-describedby"?: string;
  required?: boolean;
  disabled?: boolean;
  // Convenience mirrors for libraries that look for these flags:
  invalid?: boolean;
};

export type FieldProps = {
  label?: ReactNode;
  labelFor?: string; // override htmlFor; defaults to generated control id
  labelSuffix?: ReactNode; // optional inline element on the right of the label row (e.g., "optional")
  hint?: ReactNode;
  error?: ReactNode;
  required?: boolean;
  disabled?: boolean;
  id?: string; // id for the primary control; autogenerated if omitted
  name?: string; // not used internally; kept for external mapping
  inline?: boolean; // label on the left, control on the right
  className?: string;
  style?: CSSProperties;
  children: ReactNode | ((a11y: ControlA11yProps) => ReactNode);
};

const rowStyle: CSSProperties = {
  display: "flex",
  alignItems: "baseline",
  justifyContent: "space-between",
  gap: 8,
};

const baseStyle: CSSProperties = {
  display: "grid",
  gap: 6,
};

const inlineGrid: CSSProperties = {
  display: "grid",
  gridTemplateColumns: "minmax(120px, 200px) 1fr",
  gap: 12,
  alignItems: "center",
};

const labelStyle: CSSProperties = {
  fontSize: 13,
  fontWeight: 700,
  color: "var(--label-fg, var(--text-2, #334155))",
};

const reqStarStyle: CSSProperties = {
  color: "var(--danger-600, #dc2626)",
  marginLeft: 4,
  fontWeight: 800,
};

const hintStyle: CSSProperties = {
  fontSize: 12,
  color: "var(--muted-fg, #6b7280)",
};

const errorStyle: CSSProperties = {
  fontSize: 12,
  color: "var(--danger-600, #dc2626)",
  fontWeight: 600,
};

function mergeDescribedBy(existing?: string, ...ids: (string | undefined)[]) {
  const parts = (existing ? existing.split(/\s+/) : []).concat(ids.filter(Boolean) as string[]);
  return Array.from(new Set(parts)).join(" ").trim() || undefined;
}

function isReactElement(x: any): x is ReactElement {
  return Boolean(x) && typeof x === "object" && "type" in x && "props" in x;
}

export const Field: React.FC<FieldProps> & {
  Label: React.FC<{ htmlFor?: string; children: ReactNode; required?: boolean; suffix?: ReactNode }>;
  Hint: React.FC<{ id?: string; children: ReactNode }>;
  Error: React.FC<{ id?: string; children: ReactNode }>;
} = (props: FieldProps) => {
  const {
    label,
    labelFor,
    labelSuffix,
    hint,
    error,
    required,
    disabled,
    id,
    inline,
    className,
    style,
    children,
  } = props;

  const rid = useId();
  const inputId = id || `fld-${rid}`;
  const hintId = `fld-${rid}-hint`;
  const errId = `fld-${rid}-err`;

  const invalid = Boolean(error);

  const a11y: ControlA11yProps = {
    id: inputId,
    "aria-invalid": invalid || undefined,
    "aria-required": required || undefined,
    "aria-describedby": mergeDescribedBy(undefined, hint ? hintId : undefined, error ? errId : undefined),
    required,
    disabled,
    invalid,
  };

  // Render control: clone the single child if it's a ReactElement; otherwise use render-prop.
  let control: ReactNode;
  if (typeof children === "function") {
    control = (children as (a: ControlA11yProps) => ReactNode)(a11y);
  } else if (isReactElement(children)) {
    const existingDescribedBy = children.props?.["aria-describedby"] as string | undefined;
    control = React.cloneElement(children, {
      id: children.props?.id ?? a11y.id,
      disabled: children.props?.disabled ?? disabled,
      "aria-invalid": children.props?.["aria-invalid"] ?? a11y["aria-invalid"],
      "aria-required": children.props?.["aria-required"] ?? a11y["aria-required"],
      "aria-describedby": mergeDescribedBy(existingDescribedBy, a11y["aria-describedby"]),
      "data-invalid": invalid ? "" : undefined,
      "data-required": required ? "" : undefined,
    });
  } else {
    // Not a valid element; render as-is (no injection)
    control = children;
  }

  const containerStyle: CSSProperties = {
    ...baseStyle,
    ...(inline ? inlineGrid : {}),
    ...(style || {}),
  };

  // Wrapper will carry data-invalid/required for styling hooks
  return (
    <div
      className={className}
      style={containerStyle}
      data-invalid={invalid ? "" : undefined}
      data-required={required ? "" : undefined}
    >
      {/* Label column/row */}
      {label ? (
        <div style={inline ? undefined : rowStyle}>
          <label
            htmlFor={labelFor || inputId}
            style={labelStyle}
            title={required ? "Required" : undefined}
          >
            {label}
            {required ? (
              <abbr title="required" aria-hidden style={reqStarStyle}>
                *
              </abbr>
            ) : null}
          </label>
          {labelSuffix ? <div style={{ fontSize: 12, color: "#6b7280" }}>{labelSuffix}</div> : null}
        </div>
      ) : inline ? <div /> : null}

      {/* Control column */}
      <div style={{ display: "grid", gap: 6 }}>
        {control}
        {hint ? (
          <div id={hintId} style={hintStyle}>
            {hint}
          </div>
        ) : null}
        {error ? (
          <div id={errId} role="alert" aria-live="polite" style={errorStyle}>
            {error}
          </div>
        ) : null}
      </div>
    </div>
  );
};

Field.Label = function FieldLabel({
  htmlFor,
  children,
  required,
  suffix,
}: {
  htmlFor?: string;
  children: ReactNode;
  required?: boolean;
  suffix?: ReactNode;
}) {
  return (
    <div style={rowStyle}>
      <label htmlFor={htmlFor} style={labelStyle}>
        {children}
        {required ? (
          <abbr title="required" aria-hidden style={reqStarStyle}>
            *
          </abbr>
        ) : null}
      </label>
      {suffix ? <div style={{ fontSize: 12, color: "#6b7280" }}>{suffix}</div> : null}
    </div>
  );
};

Field.Hint = function FieldHint({ id, children }: { id?: string; children: ReactNode }) {
  return (
    <div id={id} style={hintStyle}>
      {children}
    </div>
  );
};

Field.Error = function FieldError({ id, children }: { id?: string; children: ReactNode }) {
  return (
    <div id={id} role="alert" aria-live="polite" style={errorStyle}>
      {children}
    </div>
  );
};

export default Field;
