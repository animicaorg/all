"""
Animica | proofs.utils.keccak_stream

Streaming Keccak/SHAKE utilities used for *header/nonce binding* and any place
we need a deterministic pseudorandom byte/word stream derived from a transcript
(e.g., header sign-bytes || mixSeed || nonce).  This is intentionally tiny,
pure-Python, and dependency-free (relies only on `hashlib` SHA3/SHAKE).

Design goals
------------
- Deterministic across platforms (uses hashlib.sha3_* / shake_*).
- Domain-separated frames (length-prefixed chunks) to avoid collisions.
- "Stream" API that amortizes SHAKE output so multiple `squeeze()` calls do not
  re-hash O(n^2).
- Helpers for u-draws: unbiased floats in (0,1) with 53-bit precision suitable
  for `H(u) = −ln(u)` in consensus.
- Header/nonce binding constructor that mirrors spec/domains.yaml strings.

IMPORTANT: Ensure the domain tags passed here match `spec/domains.yaml`. Defaults
are provided but network deployments MUST keep them in sync.

Examples
--------
>>> ks = header_nonce_stream(b"hdr-signbytes", nonce=42, mix_seed=bytes.fromhex("00"*32))
>>> ks.rand_u64()  # deterministic 64-bit word
>>> ks.u01_open()  # 53-bit open interval (0,1)

"""

from __future__ import annotations

import hashlib
import math
from typing import Iterable, Optional, Tuple, List

# --------------------------------------------------------------------------------------
# Domain tags (should mirror spec/domains.yaml; customizable at call sites)
# --------------------------------------------------------------------------------------

DOMAIN_HEADER_NONCE = b"ANIMICA|hash.header_nonce|v1"
DOMAIN_USTREAM = b"ANIMICA|ustream|v1"


# --------------------------------------------------------------------------------------
# Internal: canonical uvarint length prefix (little-endian base-128)
# --------------------------------------------------------------------------------------

def _uvarint(n: int) -> bytes:
    """Encode non-negative int as uvarint (base-128, LE)."""
    if n < 0:
        raise ValueError("uvarint: negative")
    out = bytearray()
    while True:
        b = n & 0x7F
        n >>= 7
        if n:
            out.append(b | 0x80)
        else:
            out.append(b)
            break
    return bytes(out)


def _frame(domain: bytes, chunks: Iterable[bytes]) -> bytes:
    """
    Frame bytes with domain separation and length prefixes:

        frame = b"ANIMICA\x1E" || len(domain) || domain || Σ (len(ci) || ci)

    The sentinel 0x1E is a visual unit separator (US). Lengths are uvarint.
    """
    if not isinstance(domain, (bytes, bytearray)):
        raise TypeError("domain must be bytes")
    framed = bytearray(b"ANIMICA\x1E")
    framed += _uvarint(len(domain)) + domain
    for c in chunks:
        if not isinstance(c, (bytes, bytearray)):
            raise TypeError("chunk must be bytes")
        framed += _uvarint(len(c)) + c
    return bytes(framed)


# --------------------------------------------------------------------------------------
# Keccak stream based on SHAKE-256
# --------------------------------------------------------------------------------------

class KeccakStream:
    """
    Keccak-based extendable-output stream (SHAKE-256) with amortized output.

    This object is *seek-only-forward*: each `squeeze(n)` advances an internal
    cursor and returns the next `n` bytes from the infinite SHAKE stream.

    Implementation detail: CPython's hashlib `shake_256().digest(m)` always
    returns the first `m` bytes from the stream (does not advance). To avoid
    O(n^2), we cache the generated bytes and only request additional output
    when needed.
    """

    __slots__ = ("_seed", "_cache", "_off")

    def __init__(self, seed_material: bytes):
        self._seed = seed_material  # immutable, framed & domain-separated
        self._cache = bytearray()
        self._off = 0  # next unread index in cache

    @staticmethod
    def from_chunks(*, domain: bytes, chunks: Iterable[bytes]) -> "KeccakStream":
        return KeccakStream(_frame(domain, chunks))

    def _ensure(self, nbytes: int) -> None:
        """Ensure at least `nbytes` unread bytes remain in the cache."""
        need = self._off + nbytes
        if need <= len(self._cache):
            return
        # Generate to total length = need; extend cache with the delta only.
        shake = hashlib.shake_256(self._seed)
        out = shake.digest(need)
        # Replace the cache only if we grew (idempotent for small requests).
        if len(out) > len(self._cache):
            self._cache[:] = out

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def squeeze(self, n: int) -> bytes:
        """Return next n bytes from the stream and advance the cursor."""
        if n < 0:
            raise ValueError("squeeze: n < 0")
        if n == 0:
            return b""
        self._ensure(n)
        start = self._off
        end = start + n
        self._off = end
        return bytes(self._cache[start:end])

    def rand_u64(self) -> int:
        """Return next 64-bit unsigned integer (big-endian)."""
        return int.from_bytes(self.squeeze(8), "big", signed=False)

    def rand_u256(self) -> int:
        """Return next 256-bit unsigned integer (big-endian)."""
        return int.from_bytes(self.squeeze(32), "big", signed=False)

    def u01_open(self) -> float:
        """
        Return a float uniformly in the *open* interval (0, 1) with 53-bit precision.

        We draw 53 random bits (the full mantissa width of IEEE-754 double),
        interpret as integer r ∈ [0, 2^53−1], and return (r+1)/2^53 so the
        result is strictly > 0 and ≤ 1.0. To avoid returning exactly 1.0,
        we resample if r == 2^53−1 (rare).
        """
        while True:
            # 53 bits: take 7 bytes (56 bits) and drop the lowest 3 bits to avoid bias.
            r56 = int.from_bytes(self.squeeze(7), "big")
            r = r56 >> 3  # keep high 53 bits
            if r == (1 << 53) - 1:
                # Would map to 1.0; resample
                continue
            # (r + 1) / 2^53 ensures strictly > 0
            return (r + 1) / float(1 << 53)

    def fork(self, *extra_chunks: bytes, domain: Optional[bytes] = None) -> "KeccakStream":
        """
        Derive a child stream with additional domain/chunks (like HKDF "expand").
        If `domain` is None, use DOMAIN_USTREAM.
        """
        d = domain if domain is not None else DOMAIN_USTREAM
        return KeccakStream.from_chunks(domain=d, chunks=(self._seed, *_normalize_chunks(extra_chunks)))

    def peek_bytes(self, n: int) -> bytes:
        """
        Non-advancing read of the next `n` bytes (useful for previews). This is
        implemented by `squeeze(n)` + negative seek via internal cursor reset.
        """
        if n < 0:
            raise ValueError("peek_bytes: n < 0")
        old = self._off
        try:
            data = self.squeeze(n)
        finally:
            self._off = old
        return data

    def tell(self) -> int:
        """Return current cursor offset (bytes consumed)."""
        return self._off

    def seek(self, pos: int) -> None:
        """
        Seek to absolute position `pos` in the stream (only forward is supported).
        """
        if pos < self._off:
            raise ValueError("seek: cannot move backward")
        self._ensure(pos - self._off)
        self._off = pos


def _normalize_chunks(chunks: Iterable[bytes]) -> Tuple[bytes, ...]:
    out: List[bytes] = []
    for c in chunks:
        if not isinstance(c, (bytes, bytearray)):
            raise TypeError("chunk must be bytes")
        out.append(bytes(c))
    return tuple(out)


# --------------------------------------------------------------------------------------
# Header/nonce binding helpers
# --------------------------------------------------------------------------------------

def header_nonce_stream(
    header_sign_bytes: bytes,
    *,
    nonce: int,
    mix_seed: bytes,
    domain: bytes = DOMAIN_HEADER_NONCE,
) -> KeccakStream:
    """
    Create a KeccakStream bound to (header_sign_bytes, mix_seed, nonce).

    - `header_sign_bytes` is the canonical header "SignBytes" (see core/encoding/canonical.py)
    - `mix_seed` is the 32-byte mixSeed from the *parent* header or randomness beacon input
    - `nonce` is encoded as 8-byte big-endian unsigned integer

    Domain tag defaults to DOMAIN_HEADER_NONCE; keep this aligned with spec/domains.yaml.
    """
    if nonce < 0 or nonce > (1 << 64) - 1:
        raise ValueError("nonce out of range (0..2^64-1)")
    nonce_be = nonce.to_bytes(8, "big", signed=False)
    seed = _frame(domain, (header_sign_bytes, mix_seed, nonce_be))
    return KeccakStream(seed)


def bind_keccak256(*, domain: bytes, chunks: Iterable[bytes]) -> bytes:
    """
    Single-shot Keccak-256 (FIPS SHA3-256) over a framed transcript.
    """
    h = hashlib.sha3_256()
    h.update(_frame(domain, chunks))
    return h.digest()


# --------------------------------------------------------------------------------------
# u-draw helpers (header/nonce → u in (0,1))
# --------------------------------------------------------------------------------------

def udraw_open01(
    header_sign_bytes: bytes,
    *,
    nonce: int,
    mix_seed: bytes,
    domain: bytes = DOMAIN_HEADER_NONCE,
) -> float:
    """
    Convenience function: derive a stream from (header, mix_seed, nonce) and
    return a single u ∈ (0,1) with 53-bit precision suitable for H(u).
    """
    ks = header_nonce_stream(header_sign_bytes, nonce=nonce, mix_seed=mix_seed, domain=domain)
    return ks.u01_open()


# --------------------------------------------------------------------------------------
# Self-checks
# --------------------------------------------------------------------------------------

if __name__ == "__main__":  # pragma: no cover
    hdr = b"header-signbytes-example"
    mix = bytes.fromhex("a5" * 32)
    ks1 = header_nonce_stream(hdr, nonce=0, mix_seed=mix)
    ks2 = header_nonce_stream(hdr, nonce=0, mix_seed=mix)
    assert ks1.peek_bytes(16) == ks2.peek_bytes(16), "determinism failed"

    # Stream cursor behavior
    b1 = ks1.squeeze(16)
    b2 = ks1.squeeze(16)
    assert len(b1) == 16 and len(b2) == 16 and b1 != b2
    assert ks1.tell() == 32

    # u-draw range & reproducibility
    u = udraw_open01(hdr, nonce=123456789, mix_seed=mix)
    assert 0.0 < u <= 1.0
    u2 = udraw_open01(hdr, nonce=123456789, mix_seed=mix)
    assert u == u2

    # Keccak-256 bind smoke test
    d = bind_keccak256(domain=b"ANIMICA|test|v1", chunks=[b"foo", b"bar"])
    assert len(d) == 32
    print("keccak_stream OK")
